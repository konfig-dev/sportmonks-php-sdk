<?php
/**
 * SportApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Sportmonks
 * @author   Konfig
 * @link     https://konfigthis.com
 */

/**
 * SportMonks
 *
 * Surpass the competition with superior sports data
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://konfigthis.com
 */


namespace Sportmonks\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\BodySummarizer;
use GuzzleHttp\Middleware;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Utils;
use Sportmonks\ApiException;
use Sportmonks\Configuration;
use Sportmonks\HeaderSelector;
use Sportmonks\ObjectSerializer;

class SportApi extends \Sportmonks\CustomApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'coachById' => [
            'application/json',
        ],
        'coachesAll' => [
            'application/json',
        ],
        'coachesByCountryId' => [
            'application/json',
        ],
        'coachesLatest' => [
            'application/json',
        ],
        'coachesSearch' => [
            'application/json',
        ],
        'commentariesAll' => [
            'application/json',
        ],
        'commentariesByFixtureId' => [
            'application/json',
        ],
        'fixtureByDateRangeForTeam' => [
            'application/json',
        ],
        'fixtureById' => [
            'application/json',
        ],
        'fixturesAll' => [
            'application/json',
        ],
        'fixturesByDate' => [
            'application/json',
        ],
        'fixturesByDateRange' => [
            'application/json',
        ],
        'fixturesByIds' => [
            'application/json',
        ],
        'fixturesHeadToHead' => [
            'application/json',
        ],
        'fixturesLatest' => [
            'application/json',
        ],
        'fixturesSearch' => [
            'application/json',
        ],
        'leagueById' => [
            'application/json',
        ],
        'leagueEnrichments' => [
            'application/json',
        ],
        'leagueShirts' => [
            'application/json',
        ],
        'leaguesAll' => [
            'application/json',
        ],
        'leaguesByCountryId' => [
            'application/json',
        ],
        'leaguesByDate' => [
            'application/json',
        ],
        'leaguesByTeamId' => [
            'application/json',
        ],
        'leaguesCurrentByTeamId' => [
            'application/json',
        ],
        'leaguesLive' => [
            'application/json',
        ],
        'leaguesSearch' => [
            'application/json',
        ],
        'livescoresAll' => [
            'application/json',
        ],
        'livescoresAllInPlay' => [
            'application/json',
        ],
        'livescoresLatest' => [
            'application/json',
        ],
        'newsAllPostMatch' => [
            'application/json',
        ],
        'newsAllPreMatch' => [
            'application/json',
        ],
        'newsPostMatchBySeasonId' => [
            'application/json',
        ],
        'newsPreMatchBySeasonId' => [
            'application/json',
        ],
        'newsUpcomingPostMatch' => [
            'application/json',
        ],
        'newsUpcomingPreMatch' => [
            'application/json',
        ],
        'oddsAllInPlay' => [
            'application/json',
        ],
        'oddsAllPreMatch' => [
            'application/json',
        ],
        'oddsInPlayByFixtureAndBookmakerId' => [
            'application/json',
        ],
        'oddsInPlayByFixtureAndMarketId' => [
            'application/json',
        ],
        'oddsInPlayByFixtureId' => [
            'application/json',
        ],
        'oddsLatestInPlay' => [
            'application/json',
        ],
        'oddsLatestPreMatch' => [
            'application/json',
        ],
        'oddsPreMatchByFixtureAndBookmakerId' => [
            'application/json',
        ],
        'oddsPreMatchByFixtureAndMarketId' => [
            'application/json',
        ],
        'oddsPreMatchByFixtureId' => [
            'application/json',
        ],
        'playerById' => [
            'application/json',
        ],
        'playersAll' => [
            'application/json',
        ],
        'playersByCountryId' => [
            'application/json',
        ],
        'playersLatest' => [
            'application/json',
        ],
        'playersSearch' => [
            'application/json',
        ],
        'predictionsAll' => [
            'application/json',
        ],
        'predictionsAllValueBets' => [
            'application/json',
        ],
        'predictionsByFixtureId' => [
            'application/json',
        ],
        'predictionsValueBetsByFixtureId' => [
            'application/json',
        ],
        'refereeById' => [
            'application/json',
        ],
        'refereesAll' => [
            'application/json',
        ],
        'refereesByCountryId' => [
            'application/json',
        ],
        'refereesBySeasonId' => [
            'application/json',
        ],
        'refereesSearch' => [
            'application/json',
        ],
        'rivalsAll' => [
            'application/json',
        ],
        'rivalsByTeamId' => [
            'application/json',
        ],
        'roundById' => [
            'application/json',
        ],
        'roundsAll' => [
            'application/json',
        ],
        'roundsBySeasonId' => [
            'application/json',
        ],
        'roundsSearch' => [
            'application/json',
        ],
        'schedulesBySeasonId' => [
            'application/json',
        ],
        'schedulesByTeamAndSeasonId' => [
            'application/json',
        ],
        'schedulesByTeamId' => [
            'application/json',
        ],
        'seasonById' => [
            'application/json',
        ],
        'seasonsAll' => [
            'application/json',
        ],
        'seasonsByTeamId' => [
            'application/json',
        ],
        'seasonsSearch' => [
            'application/json',
        ],
        'squadsBySeasonAndTeamId' => [
            'application/json',
        ],
        'squadsByTeamId' => [
            'application/json',
        ],
        'stageById' => [
            'application/json',
        ],
        'stagesAll' => [
            'application/json',
        ],
        'stagesBySeasonId' => [
            'application/json',
        ],
        'stagesSearch' => [
            'application/json',
        ],
        'standingCorrectionsBySeasonId' => [
            'application/json',
        ],
        'standingsAll' => [
            'application/json',
        ],
        'standingsByRoundId' => [
            'application/json',
        ],
        'standingsBySeasonId' => [
            'application/json',
        ],
        'standingsLiveByLeagueId' => [
            'application/json',
        ],
        'stateById' => [
            'application/json',
        ],
        'statesBySport' => [
            'application/json',
        ],
        'teamsAll' => [
            'application/json',
        ],
        'teamsByCountryId' => [
            'application/json',
        ],
        'teamsById' => [
            'application/json',
        ],
        'teamsBySeasonId' => [
            'application/json',
        ],
        'teamsSearch' => [
            'application/json',
        ],
        'topScorersBySeasonId' => [
            'application/json',
        ],
        'topScorersByStageId' => [
            'application/json',
        ],
        'tranfersByDateRange' => [
            'application/json',
        ],
        'transferById' => [
            'application/json',
        ],
        'transfersAll' => [
            'application/json',
        ],
        'transfersByPlayerId' => [
            'application/json',
        ],
        'transfersByTeamId' => [
            'application/json',
        ],
        'transfersLatest' => [
            'application/json',
        ],
        'tvStationById' => [
            'application/json',
        ],
        'tvStationsAll' => [
            'application/json',
        ],
        'tvStationsByFixtureId' => [
            'application/json',
        ],
        'venueById' => [
            'application/json',
        ],
        'venuesAll' => [
            'application/json',
        ],
        'venuesBySeasonId' => [
            'application/json',
        ],
        'venuesSearch' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $clientOptions = [];
        if (!$config->getVerifySsl()) $clientOptions["verify"] = false;

        // Do not truncate error messages
        // https://github.com/guzzle/guzzle/issues/2185#issuecomment-800293420
        $stack = new HandlerStack(Utils::chooseHandler());
        $stack->push(Middleware::httpErrors(new BodySummarizer(10000)), 'http_errors');
        $stack->push(Middleware::redirect(), 'allow_redirects');
        $stack->push(Middleware::cookies(), 'cookies');
        $stack->push(Middleware::prepareBody(), 'prepare_body');
        $clientOptions["handler"] = $stack;

        $this->client = $client ?: new Client($clientOptions);
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * For initializing request body parameter
     */
    private function setRequestBodyProperty(&$body, $property, $value) {
        if ($body === null) $body = [];
        // user did not pass in a value for this parameter
        if ($value === SENTINEL_VALUE) return;
        $body[$property] = $value;
    }

    /**
     * Operation coachById
     *
     * By ID
     *
     * @param  int $coach_id The ID of the coach you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportCoachByIdResponse
     */
    public function coachById(
        $coach_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachById'][0]

    )
    {

        list($response) = $this->coachByIdWithHttpInfo($coach_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation coachByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $coach_id The ID of the coach you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportCoachByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function coachByIdWithHttpInfo($coach_id, $version = null, $sport = null, string $contentType = self::contentTypes['coachById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachByIdRequest($coach_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->coachByIdWithHttpInfo(
                        $coach_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportCoachByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportCoachByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportCoachByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportCoachByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportCoachByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation coachByIdAsync
     *
     * By ID
     *
     * @param  int $coach_id The ID of the coach you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachByIdAsync(
        $coach_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachById'][0]

    )
    {

        return $this->coachByIdAsyncWithHttpInfo($coach_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation coachByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $coach_id The ID of the coach you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachByIdAsyncWithHttpInfo($coach_id, $version = null, $sport = null, string $contentType = self::contentTypes['coachById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportCoachByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachByIdRequest($coach_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'coachById'
     *
     * @param  int $coach_id The ID of the coach you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function coachByIdRequest($coach_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['coachById'][0])
    {

        // verify the required parameter 'coach_id' is set
        if ($coach_id === SENTINEL_VALUE || (is_array($coach_id) && count($coach_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter coach_id when calling coachById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/coaches/{coachId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($coach_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'coachId' . '}',
                ObjectSerializer::toPathValue($coach_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation coachesAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportCoachesAllResponse
     */
    public function coachesAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachesAll'][0]

    )
    {

        list($response) = $this->coachesAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation coachesAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportCoachesAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function coachesAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['coachesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->coachesAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportCoachesAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportCoachesAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportCoachesAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportCoachesAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportCoachesAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation coachesAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachesAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachesAll'][0]

    )
    {

        return $this->coachesAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation coachesAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachesAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['coachesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportCoachesAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'coachesAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function coachesAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['coachesAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/coaches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation coachesByCountryId
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve coaches from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportCoachesByCountryIdResponse
     */
    public function coachesByCountryId(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachesByCountryId'][0]

    )
    {

        list($response) = $this->coachesByCountryIdWithHttpInfo($country_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation coachesByCountryIdWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve coaches from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportCoachesByCountryIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function coachesByCountryIdWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['coachesByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachesByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->coachesByCountryIdWithHttpInfo(
                        $country_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportCoachesByCountryIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportCoachesByCountryIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportCoachesByCountryIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportCoachesByCountryIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportCoachesByCountryIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation coachesByCountryIdAsync
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve coaches from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachesByCountryIdAsync(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachesByCountryId'][0]

    )
    {

        return $this->coachesByCountryIdAsyncWithHttpInfo($country_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation coachesByCountryIdAsyncWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve coaches from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachesByCountryIdAsyncWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['coachesByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportCoachesByCountryIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachesByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'coachesByCountryId'
     *
     * @param  int $country_id The ID of the country you want to retrieve coaches from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function coachesByCountryIdRequest($country_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['coachesByCountryId'][0])
    {

        // verify the required parameter 'country_id' is set
        if ($country_id === SENTINEL_VALUE || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter country_id when calling coachesByCountryId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/coaches/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation coachesLatest
     *
     * Last updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportCoachesLatestResponse
     */
    public function coachesLatest(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachesLatest'][0]

    )
    {

        list($response) = $this->coachesLatestWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation coachesLatestWithHttpInfo
     *
     * Last updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportCoachesLatestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function coachesLatestWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['coachesLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachesLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->coachesLatestWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportCoachesLatestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportCoachesLatestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportCoachesLatestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportCoachesLatestResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportCoachesLatestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation coachesLatestAsync
     *
     * Last updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachesLatestAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachesLatest'][0]

    )
    {

        return $this->coachesLatestAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation coachesLatestAsyncWithHttpInfo
     *
     * Last updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachesLatestAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['coachesLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportCoachesLatestResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachesLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'coachesLatest'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function coachesLatestRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['coachesLatest'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/coaches/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation coachesSearch
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportCoachesSearchResponse
     */
    public function coachesSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachesSearch'][0]

    )
    {

        list($response) = $this->coachesSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation coachesSearchWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportCoachesSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function coachesSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['coachesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->coachesSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportCoachesSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportCoachesSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportCoachesSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportCoachesSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportCoachesSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation coachesSearchAsync
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachesSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['coachesSearch'][0]

    )
    {

        return $this->coachesSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation coachesSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function coachesSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['coachesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportCoachesSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->coachesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'coachesSearch'
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['coachesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function coachesSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['coachesSearch'][0])
    {

        // Check if $name is a string
        if ($name !== SENTINEL_VALUE && !is_string($name)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($name, true), gettype($name)));
        }
        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling coachesSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/coaches/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation commentariesAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportCommentariesAllResponse
     */
    public function commentariesAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['commentariesAll'][0]

    )
    {

        list($response) = $this->commentariesAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation commentariesAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportCommentariesAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function commentariesAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['commentariesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->commentariesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->commentariesAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportCommentariesAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportCommentariesAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportCommentariesAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportCommentariesAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportCommentariesAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation commentariesAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commentariesAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['commentariesAll'][0]

    )
    {

        return $this->commentariesAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation commentariesAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commentariesAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['commentariesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportCommentariesAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->commentariesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'commentariesAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function commentariesAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['commentariesAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/commentaries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation commentariesByFixtureId
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve commentaries from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportCommentariesByFixtureIdResponse
     */
    public function commentariesByFixtureId(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['commentariesByFixtureId'][0]

    )
    {

        list($response) = $this->commentariesByFixtureIdWithHttpInfo($fixture_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation commentariesByFixtureIdWithHttpInfo
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve commentaries from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportCommentariesByFixtureIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function commentariesByFixtureIdWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['commentariesByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->commentariesByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->commentariesByFixtureIdWithHttpInfo(
                        $fixture_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportCommentariesByFixtureIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportCommentariesByFixtureIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportCommentariesByFixtureIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportCommentariesByFixtureIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportCommentariesByFixtureIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation commentariesByFixtureIdAsync
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve commentaries from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commentariesByFixtureIdAsync(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['commentariesByFixtureId'][0]

    )
    {

        return $this->commentariesByFixtureIdAsyncWithHttpInfo($fixture_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation commentariesByFixtureIdAsyncWithHttpInfo
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve commentaries from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commentariesByFixtureIdAsyncWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['commentariesByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportCommentariesByFixtureIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->commentariesByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'commentariesByFixtureId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve commentaries from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['commentariesByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function commentariesByFixtureIdRequest($fixture_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['commentariesByFixtureId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling commentariesByFixtureId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/commentaries/fixtures/{fixtureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fixtureByDateRangeForTeam
     *
     * By Date Range for Team
     *
     * @param  string $start_date start_date (required)
     * @param  string $end_date end_date (required)
     * @param  string $team_id team_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureByDateRangeForTeam'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportFixtureByDateRangeForTeamResponse
     */
    public function fixtureByDateRangeForTeam(
        $start_date,
        $end_date,
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixtureByDateRangeForTeam'][0]

    )
    {

        list($response) = $this->fixtureByDateRangeForTeamWithHttpInfo($start_date, $end_date, $team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation fixtureByDateRangeForTeamWithHttpInfo
     *
     * By Date Range for Team
     *
     * @param  string $start_date (required)
     * @param  string $end_date (required)
     * @param  string $team_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureByDateRangeForTeam'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportFixtureByDateRangeForTeamResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fixtureByDateRangeForTeamWithHttpInfo($start_date, $end_date, $team_id, $version = null, $sport = null, string $contentType = self::contentTypes['fixtureByDateRangeForTeam'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixtureByDateRangeForTeamRequest($start_date, $end_date, $team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fixtureByDateRangeForTeamWithHttpInfo(
                        $start_date,
                        $end_date,
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportFixtureByDateRangeForTeamResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportFixtureByDateRangeForTeamResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportFixtureByDateRangeForTeamResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportFixtureByDateRangeForTeamResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportFixtureByDateRangeForTeamResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fixtureByDateRangeForTeamAsync
     *
     * By Date Range for Team
     *
     * @param  string $start_date (required)
     * @param  string $end_date (required)
     * @param  string $team_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureByDateRangeForTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixtureByDateRangeForTeamAsync(
        $start_date,
        $end_date,
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixtureByDateRangeForTeam'][0]

    )
    {

        return $this->fixtureByDateRangeForTeamAsyncWithHttpInfo($start_date, $end_date, $team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fixtureByDateRangeForTeamAsyncWithHttpInfo
     *
     * By Date Range for Team
     *
     * @param  string $start_date (required)
     * @param  string $end_date (required)
     * @param  string $team_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureByDateRangeForTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixtureByDateRangeForTeamAsyncWithHttpInfo($start_date, $end_date, $team_id, $version = null, $sport = null, string $contentType = self::contentTypes['fixtureByDateRangeForTeam'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportFixtureByDateRangeForTeamResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixtureByDateRangeForTeamRequest($start_date, $end_date, $team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fixtureByDateRangeForTeam'
     *
     * @param  string $start_date (required)
     * @param  string $end_date (required)
     * @param  string $team_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureByDateRangeForTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fixtureByDateRangeForTeamRequest($start_date, $end_date, $team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['fixtureByDateRangeForTeam'][0])
    {

        // Check if $start_date is a string
        if ($start_date !== SENTINEL_VALUE && !is_string($start_date)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($start_date, true), gettype($start_date)));
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === SENTINEL_VALUE || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter start_date when calling fixtureByDateRangeForTeam'
            );
        }
        // Check if $end_date is a string
        if ($end_date !== SENTINEL_VALUE && !is_string($end_date)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($end_date, true), gettype($end_date)));
        }
        // verify the required parameter 'end_date' is set
        if ($end_date === SENTINEL_VALUE || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter end_date when calling fixtureByDateRangeForTeam'
            );
        }
        // Check if $team_id is a string
        if ($team_id !== SENTINEL_VALUE && !is_string($team_id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($team_id, true), gettype($team_id)));
        }
        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling fixtureByDateRangeForTeam'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/fixtures/between/{startDate}/{endDate}/{teamId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($start_date !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'startDate' . '}',
                ObjectSerializer::toPathValue($start_date),
                $resourcePath
            );
        }
        // path params
        if ($end_date !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'endDate' . '}',
                ObjectSerializer::toPathValue($end_date),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fixtureById
     *
     * Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportFixtureByIdResponse
     */
    public function fixtureById(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixtureById'][0]

    )
    {

        list($response) = $this->fixtureByIdWithHttpInfo($fixture_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation fixtureByIdWithHttpInfo
     *
     * Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportFixtureByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fixtureByIdWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['fixtureById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixtureByIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fixtureByIdWithHttpInfo(
                        $fixture_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportFixtureByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportFixtureByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportFixtureByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportFixtureByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportFixtureByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fixtureByIdAsync
     *
     * Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixtureByIdAsync(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixtureById'][0]

    )
    {

        return $this->fixtureByIdAsyncWithHttpInfo($fixture_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fixtureByIdAsyncWithHttpInfo
     *
     * Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixtureByIdAsyncWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['fixtureById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportFixtureByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixtureByIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fixtureById'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixtureById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fixtureByIdRequest($fixture_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['fixtureById'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling fixtureById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/fixtures/{fixtureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fixturesAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportFixturesAllResponse
     */
    public function fixturesAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesAll'][0]

    )
    {

        list($response) = $this->fixturesAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation fixturesAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportFixturesAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fixturesAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['fixturesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fixturesAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportFixturesAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportFixturesAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportFixturesAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportFixturesAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportFixturesAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fixturesAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesAll'][0]

    )
    {

        return $this->fixturesAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fixturesAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['fixturesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportFixturesAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fixturesAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fixturesAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['fixturesAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/fixtures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fixturesByDate
     *
     * By Date
     *
     * @param  string $date The date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDate'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportFixturesByDateResponse
     */
    public function fixturesByDate(
        $date,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesByDate'][0]

    )
    {

        list($response) = $this->fixturesByDateWithHttpInfo($date, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation fixturesByDateWithHttpInfo
     *
     * By Date
     *
     * @param  string $date The date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDate'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportFixturesByDateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fixturesByDateWithHttpInfo($date, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesByDate'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesByDateRequest($date, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fixturesByDateWithHttpInfo(
                        $date,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportFixturesByDateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportFixturesByDateResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportFixturesByDateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportFixturesByDateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportFixturesByDateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fixturesByDateAsync
     *
     * By Date
     *
     * @param  string $date The date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesByDateAsync(
        $date,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesByDate'][0]

    )
    {

        return $this->fixturesByDateAsyncWithHttpInfo($date, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fixturesByDateAsyncWithHttpInfo
     *
     * By Date
     *
     * @param  string $date The date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesByDateAsyncWithHttpInfo($date, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesByDate'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportFixturesByDateResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesByDateRequest($date, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fixturesByDate'
     *
     * @param  string $date The date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fixturesByDateRequest($date, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['fixturesByDate'][0])
    {

        // Check if $date is a string
        if ($date !== SENTINEL_VALUE && !is_string($date)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($date, true), gettype($date)));
        }
        // verify the required parameter 'date' is set
        if ($date === SENTINEL_VALUE || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter date when calling fixturesByDate'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/fixtures/date/{date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($date !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fixturesByDateRange
     *
     * By Date Range
     *
     * @param  string $start_date The start date you want to retrieve fixtures from. (required)
     * @param  string $end_date The end date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDateRange'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportFixturesByDateRangeResponse
     */
    public function fixturesByDateRange(
        $start_date,
        $end_date,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesByDateRange'][0]

    )
    {

        list($response) = $this->fixturesByDateRangeWithHttpInfo($start_date, $end_date, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation fixturesByDateRangeWithHttpInfo
     *
     * By Date Range
     *
     * @param  string $start_date The start date you want to retrieve fixtures from. (required)
     * @param  string $end_date The end date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDateRange'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportFixturesByDateRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fixturesByDateRangeWithHttpInfo($start_date, $end_date, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesByDateRange'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesByDateRangeRequest($start_date, $end_date, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fixturesByDateRangeWithHttpInfo(
                        $start_date,
                        $end_date,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportFixturesByDateRangeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportFixturesByDateRangeResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportFixturesByDateRangeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportFixturesByDateRangeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportFixturesByDateRangeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fixturesByDateRangeAsync
     *
     * By Date Range
     *
     * @param  string $start_date The start date you want to retrieve fixtures from. (required)
     * @param  string $end_date The end date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDateRange'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesByDateRangeAsync(
        $start_date,
        $end_date,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesByDateRange'][0]

    )
    {

        return $this->fixturesByDateRangeAsyncWithHttpInfo($start_date, $end_date, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fixturesByDateRangeAsyncWithHttpInfo
     *
     * By Date Range
     *
     * @param  string $start_date The start date you want to retrieve fixtures from. (required)
     * @param  string $end_date The end date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDateRange'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesByDateRangeAsyncWithHttpInfo($start_date, $end_date, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesByDateRange'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportFixturesByDateRangeResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesByDateRangeRequest($start_date, $end_date, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fixturesByDateRange'
     *
     * @param  string $start_date The start date you want to retrieve fixtures from. (required)
     * @param  string $end_date The end date you want to retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByDateRange'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fixturesByDateRangeRequest($start_date, $end_date, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['fixturesByDateRange'][0])
    {

        // Check if $start_date is a string
        if ($start_date !== SENTINEL_VALUE && !is_string($start_date)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($start_date, true), gettype($start_date)));
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === SENTINEL_VALUE || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter start_date when calling fixturesByDateRange'
            );
        }
        // Check if $end_date is a string
        if ($end_date !== SENTINEL_VALUE && !is_string($end_date)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($end_date, true), gettype($end_date)));
        }
        // verify the required parameter 'end_date' is set
        if ($end_date === SENTINEL_VALUE || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter end_date when calling fixturesByDateRange'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/fixtures/between/{startDate}/{endDate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($start_date !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'startDate' . '}',
                ObjectSerializer::toPathValue($start_date),
                $resourcePath
            );
        }
        // path params
        if ($end_date !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'endDate' . '}',
                ObjectSerializer::toPathValue($end_date),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fixturesByIds
     *
     * By IDs
     *
     * @param  string $fixture_ids The IDs you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByIds'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportFixturesByIdsResponse
     */
    public function fixturesByIds(
        $fixture_ids,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesByIds'][0]

    )
    {

        list($response) = $this->fixturesByIdsWithHttpInfo($fixture_ids, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation fixturesByIdsWithHttpInfo
     *
     * By IDs
     *
     * @param  string $fixture_ids The IDs you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByIds'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportFixturesByIdsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fixturesByIdsWithHttpInfo($fixture_ids, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesByIds'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesByIdsRequest($fixture_ids, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fixturesByIdsWithHttpInfo(
                        $fixture_ids,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportFixturesByIdsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportFixturesByIdsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportFixturesByIdsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportFixturesByIdsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportFixturesByIdsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fixturesByIdsAsync
     *
     * By IDs
     *
     * @param  string $fixture_ids The IDs you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesByIdsAsync(
        $fixture_ids,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesByIds'][0]

    )
    {

        return $this->fixturesByIdsAsyncWithHttpInfo($fixture_ids, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fixturesByIdsAsyncWithHttpInfo
     *
     * By IDs
     *
     * @param  string $fixture_ids The IDs you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesByIdsAsyncWithHttpInfo($fixture_ids, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesByIds'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportFixturesByIdsResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesByIdsRequest($fixture_ids, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fixturesByIds'
     *
     * @param  string $fixture_ids The IDs you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesByIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fixturesByIdsRequest($fixture_ids, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['fixturesByIds'][0])
    {

        // Check if $fixture_ids is a string
        if ($fixture_ids !== SENTINEL_VALUE && !is_string($fixture_ids)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($fixture_ids, true), gettype($fixture_ids)));
        }
        // verify the required parameter 'fixture_ids' is set
        if ($fixture_ids === SENTINEL_VALUE || (is_array($fixture_ids) && count($fixture_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_ids when calling fixturesByIds'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/fixtures/multi/{fixtureIds}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_ids !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureIds' . '}',
                ObjectSerializer::toPathValue($fixture_ids),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fixturesHeadToHead
     *
     * Head to Head
     *
     * @param  int $first_team The ID of the first team retrieve fixtures from. (required)
     * @param  int $second_team The ID of the second team retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesHeadToHead'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportFixturesHeadToHeadResponse
     */
    public function fixturesHeadToHead(
        $first_team,
        $second_team,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesHeadToHead'][0]

    )
    {

        list($response) = $this->fixturesHeadToHeadWithHttpInfo($first_team, $second_team, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation fixturesHeadToHeadWithHttpInfo
     *
     * Head to Head
     *
     * @param  int $first_team The ID of the first team retrieve fixtures from. (required)
     * @param  int $second_team The ID of the second team retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesHeadToHead'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportFixturesHeadToHeadResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fixturesHeadToHeadWithHttpInfo($first_team, $second_team, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesHeadToHead'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesHeadToHeadRequest($first_team, $second_team, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fixturesHeadToHeadWithHttpInfo(
                        $first_team,
                        $second_team,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportFixturesHeadToHeadResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportFixturesHeadToHeadResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportFixturesHeadToHeadResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportFixturesHeadToHeadResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportFixturesHeadToHeadResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fixturesHeadToHeadAsync
     *
     * Head to Head
     *
     * @param  int $first_team The ID of the first team retrieve fixtures from. (required)
     * @param  int $second_team The ID of the second team retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesHeadToHead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesHeadToHeadAsync(
        $first_team,
        $second_team,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesHeadToHead'][0]

    )
    {

        return $this->fixturesHeadToHeadAsyncWithHttpInfo($first_team, $second_team, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fixturesHeadToHeadAsyncWithHttpInfo
     *
     * Head to Head
     *
     * @param  int $first_team The ID of the first team retrieve fixtures from. (required)
     * @param  int $second_team The ID of the second team retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesHeadToHead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesHeadToHeadAsyncWithHttpInfo($first_team, $second_team, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesHeadToHead'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportFixturesHeadToHeadResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesHeadToHeadRequest($first_team, $second_team, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fixturesHeadToHead'
     *
     * @param  int $first_team The ID of the first team retrieve fixtures from. (required)
     * @param  int $second_team The ID of the second team retrieve fixtures from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesHeadToHead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fixturesHeadToHeadRequest($first_team, $second_team, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['fixturesHeadToHead'][0])
    {

        // verify the required parameter 'first_team' is set
        if ($first_team === SENTINEL_VALUE || (is_array($first_team) && count($first_team) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter first_team when calling fixturesHeadToHead'
            );
        }
        // verify the required parameter 'second_team' is set
        if ($second_team === SENTINEL_VALUE || (is_array($second_team) && count($second_team) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter second_team when calling fixturesHeadToHead'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/fixtures/head-to-head/{firstTeam}/{secondTeam}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($first_team !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'firstTeam' . '}',
                ObjectSerializer::toPathValue($first_team),
                $resourcePath
            );
        }
        // path params
        if ($second_team !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'secondTeam' . '}',
                ObjectSerializer::toPathValue($second_team),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fixturesLatest
     *
     * Last Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function fixturesLatest(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesLatest'][0]

    )
    {

        list($response) = $this->fixturesLatestWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation fixturesLatestWithHttpInfo
     *
     * Last Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function fixturesLatestWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['fixturesLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fixturesLatestWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fixturesLatestAsync
     *
     * Last Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesLatestAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesLatest'][0]

    )
    {

        return $this->fixturesLatestAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fixturesLatestAsyncWithHttpInfo
     *
     * Last Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesLatestAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['fixturesLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'string';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fixturesLatest'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fixturesLatestRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['fixturesLatest'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/fixtures/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fixturesSearch
     *
     * Search
     *
     * @param  string $name The name you want search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportFixturesSearchResponse
     */
    public function fixturesSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesSearch'][0]

    )
    {

        list($response) = $this->fixturesSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation fixturesSearchWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportFixturesSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fixturesSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fixturesSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportFixturesSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportFixturesSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportFixturesSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportFixturesSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportFixturesSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fixturesSearchAsync
     *
     * Search
     *
     * @param  string $name The name you want search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['fixturesSearch'][0]

    )
    {

        return $this->fixturesSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fixturesSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fixturesSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['fixturesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportFixturesSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fixturesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fixturesSearch'
     *
     * @param  string $name The name you want search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fixturesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fixturesSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['fixturesSearch'][0])
    {

        // Check if $name is a string
        if ($name !== SENTINEL_VALUE && !is_string($name)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($name, true), gettype($name)));
        }
        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling fixturesSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/fixtures/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leagueById
     *
     * By ID
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportLeagueByIdResponse
     */
    public function leagueById(
        $league_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leagueById'][0]

    )
    {

        list($response) = $this->leagueByIdWithHttpInfo($league_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leagueByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportLeagueByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function leagueByIdWithHttpInfo($league_id, $version = null, $sport = null, string $contentType = self::contentTypes['leagueById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leagueByIdRequest($league_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leagueByIdWithHttpInfo(
                        $league_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportLeagueByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportLeagueByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportLeagueByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportLeagueByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportLeagueByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leagueByIdAsync
     *
     * By ID
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leagueByIdAsync(
        $league_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leagueById'][0]

    )
    {

        return $this->leagueByIdAsyncWithHttpInfo($league_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leagueByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leagueByIdAsyncWithHttpInfo($league_id, $version = null, $sport = null, string $contentType = self::contentTypes['leagueById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportLeagueByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leagueByIdRequest($league_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leagueById'
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leagueByIdRequest($league_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leagueById'][0])
    {

        // verify the required parameter 'league_id' is set
        if ($league_id === SENTINEL_VALUE || (is_array($league_id) && count($league_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter league_id when calling leagueById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/leagues/{leagueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($league_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'leagueId' . '}',
                ObjectSerializer::toPathValue($league_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leagueEnrichments
     *
     * Enrichments
     *
     * @param  int $league_id The ID of the league you want to retrieve enrichments from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueEnrichments'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function leagueEnrichments(
        $league_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leagueEnrichments'][0]

    )
    {

        list($response) = $this->leagueEnrichmentsWithHttpInfo($league_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leagueEnrichmentsWithHttpInfo
     *
     * Enrichments
     *
     * @param  int $league_id The ID of the league you want to retrieve enrichments from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueEnrichments'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function leagueEnrichmentsWithHttpInfo($league_id, $version = null, $sport = null, string $contentType = self::contentTypes['leagueEnrichments'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leagueEnrichmentsRequest($league_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leagueEnrichmentsWithHttpInfo(
                        $league_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leagueEnrichmentsAsync
     *
     * Enrichments
     *
     * @param  int $league_id The ID of the league you want to retrieve enrichments from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueEnrichments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leagueEnrichmentsAsync(
        $league_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leagueEnrichments'][0]

    )
    {

        return $this->leagueEnrichmentsAsyncWithHttpInfo($league_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leagueEnrichmentsAsyncWithHttpInfo
     *
     * Enrichments
     *
     * @param  int $league_id The ID of the league you want to retrieve enrichments from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueEnrichments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leagueEnrichmentsAsyncWithHttpInfo($league_id, $version = null, $sport = null, string $contentType = self::contentTypes['leagueEnrichments'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leagueEnrichmentsRequest($league_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leagueEnrichments'
     *
     * @param  int $league_id The ID of the league you want to retrieve enrichments from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueEnrichments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leagueEnrichmentsRequest($league_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leagueEnrichments'][0])
    {

        // verify the required parameter 'league_id' is set
        if ($league_id === SENTINEL_VALUE || (is_array($league_id) && count($league_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter league_id when calling leagueEnrichments'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/leagues/{leagueId}/includes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($league_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'leagueId' . '}',
                ObjectSerializer::toPathValue($league_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leagueShirts
     *
     * Shirts By League ID
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueShirts'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function leagueShirts(
        $league_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leagueShirts'][0]

    )
    {

        list($response) = $this->leagueShirtsWithHttpInfo($league_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leagueShirtsWithHttpInfo
     *
     * Shirts By League ID
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueShirts'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function leagueShirtsWithHttpInfo($league_id, $version = null, $sport = null, string $contentType = self::contentTypes['leagueShirts'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leagueShirtsRequest($league_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leagueShirtsWithHttpInfo(
                        $league_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leagueShirtsAsync
     *
     * Shirts By League ID
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueShirts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leagueShirtsAsync(
        $league_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leagueShirts'][0]

    )
    {

        return $this->leagueShirtsAsyncWithHttpInfo($league_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leagueShirtsAsyncWithHttpInfo
     *
     * Shirts By League ID
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueShirts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leagueShirtsAsyncWithHttpInfo($league_id, $version = null, $sport = null, string $contentType = self::contentTypes['leagueShirts'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leagueShirtsRequest($league_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leagueShirts'
     *
     * @param  int $league_id The ID of the league you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leagueShirts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leagueShirtsRequest($league_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leagueShirts'][0])
    {

        // verify the required parameter 'league_id' is set
        if ($league_id === SENTINEL_VALUE || (is_array($league_id) && count($league_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter league_id when calling leagueShirts'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/leagues/{leagueId}/jerseys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($league_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'leagueId' . '}',
                ObjectSerializer::toPathValue($league_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leaguesAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportLeaguesAllResponse
     */
    public function leaguesAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesAll'][0]

    )
    {

        list($response) = $this->leaguesAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leaguesAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportLeaguesAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaguesAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['leaguesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leaguesAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportLeaguesAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportLeaguesAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportLeaguesAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportLeaguesAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportLeaguesAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaguesAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesAll'][0]

    )
    {

        return $this->leaguesAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaguesAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['leaguesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportLeaguesAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaguesAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaguesAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leaguesAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/leagues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leaguesByCountryId
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportLeaguesByCountryIdResponse
     */
    public function leaguesByCountryId(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesByCountryId'][0]

    )
    {

        list($response) = $this->leaguesByCountryIdWithHttpInfo($country_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leaguesByCountryIdWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportLeaguesByCountryIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaguesByCountryIdWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leaguesByCountryIdWithHttpInfo(
                        $country_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportLeaguesByCountryIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportLeaguesByCountryIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportLeaguesByCountryIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportLeaguesByCountryIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportLeaguesByCountryIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaguesByCountryIdAsync
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesByCountryIdAsync(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesByCountryId'][0]

    )
    {

        return $this->leaguesByCountryIdAsyncWithHttpInfo($country_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaguesByCountryIdAsyncWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesByCountryIdAsyncWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportLeaguesByCountryIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaguesByCountryId'
     *
     * @param  int $country_id The ID of the country you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaguesByCountryIdRequest($country_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leaguesByCountryId'][0])
    {

        // verify the required parameter 'country_id' is set
        if ($country_id === SENTINEL_VALUE || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter country_id when calling leaguesByCountryId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/leagues/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leaguesByDate
     *
     * By Date
     *
     * @param  string $date The date of fixtures you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByDate'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportLeaguesByDateResponse
     */
    public function leaguesByDate(
        $date,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesByDate'][0]

    )
    {

        list($response) = $this->leaguesByDateWithHttpInfo($date, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leaguesByDateWithHttpInfo
     *
     * By Date
     *
     * @param  string $date The date of fixtures you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByDate'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportLeaguesByDateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaguesByDateWithHttpInfo($date, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesByDate'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesByDateRequest($date, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leaguesByDateWithHttpInfo(
                        $date,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportLeaguesByDateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportLeaguesByDateResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportLeaguesByDateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportLeaguesByDateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportLeaguesByDateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaguesByDateAsync
     *
     * By Date
     *
     * @param  string $date The date of fixtures you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByDate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesByDateAsync(
        $date,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesByDate'][0]

    )
    {

        return $this->leaguesByDateAsyncWithHttpInfo($date, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaguesByDateAsyncWithHttpInfo
     *
     * By Date
     *
     * @param  string $date The date of fixtures you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByDate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesByDateAsyncWithHttpInfo($date, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesByDate'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportLeaguesByDateResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesByDateRequest($date, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaguesByDate'
     *
     * @param  string $date The date of fixtures you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByDate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaguesByDateRequest($date, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leaguesByDate'][0])
    {

        // Check if $date is a string
        if ($date !== SENTINEL_VALUE && !is_string($date)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($date, true), gettype($date)));
        }
        // verify the required parameter 'date' is set
        if ($date === SENTINEL_VALUE || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter date when calling leaguesByDate'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/leagues/date/{date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($date !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leaguesByTeamId
     *
     * Leagues By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function leaguesByTeamId(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesByTeamId'][0]

    )
    {

        list($response) = $this->leaguesByTeamIdWithHttpInfo($team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leaguesByTeamIdWithHttpInfo
     *
     * Leagues By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaguesByTeamIdWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leaguesByTeamIdWithHttpInfo(
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaguesByTeamIdAsync
     *
     * Leagues By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesByTeamIdAsync(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesByTeamId'][0]

    )
    {

        return $this->leaguesByTeamIdAsyncWithHttpInfo($team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaguesByTeamIdAsyncWithHttpInfo
     *
     * Leagues By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesByTeamIdAsyncWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaguesByTeamId'
     *
     * @param  int $team_id The ID of the team you want to retrieve leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaguesByTeamIdRequest($team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leaguesByTeamId'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling leaguesByTeamId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/teams/{teamId}/leagues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leaguesCurrentByTeamId
     *
     * Current Leagues By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve current leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesCurrentByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function leaguesCurrentByTeamId(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesCurrentByTeamId'][0]

    )
    {

        list($response) = $this->leaguesCurrentByTeamIdWithHttpInfo($team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leaguesCurrentByTeamIdWithHttpInfo
     *
     * Current Leagues By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve current leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesCurrentByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaguesCurrentByTeamIdWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesCurrentByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesCurrentByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leaguesCurrentByTeamIdWithHttpInfo(
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaguesCurrentByTeamIdAsync
     *
     * Current Leagues By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve current leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesCurrentByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesCurrentByTeamIdAsync(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesCurrentByTeamId'][0]

    )
    {

        return $this->leaguesCurrentByTeamIdAsyncWithHttpInfo($team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaguesCurrentByTeamIdAsyncWithHttpInfo
     *
     * Current Leagues By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve current leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesCurrentByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesCurrentByTeamIdAsyncWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesCurrentByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesCurrentByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaguesCurrentByTeamId'
     *
     * @param  int $team_id The ID of the team you want to retrieve current leagues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesCurrentByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaguesCurrentByTeamIdRequest($team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leaguesCurrentByTeamId'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling leaguesCurrentByTeamId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/teams/{teamId}/leagues/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leaguesLive
     *
     * Live
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesLive'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportLeaguesLiveResponse
     */
    public function leaguesLive(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesLive'][0]

    )
    {

        list($response) = $this->leaguesLiveWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leaguesLiveWithHttpInfo
     *
     * Live
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesLive'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportLeaguesLiveResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaguesLiveWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['leaguesLive'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesLiveRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leaguesLiveWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportLeaguesLiveResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportLeaguesLiveResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportLeaguesLiveResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportLeaguesLiveResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportLeaguesLiveResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaguesLiveAsync
     *
     * Live
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesLive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesLiveAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesLive'][0]

    )
    {

        return $this->leaguesLiveAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaguesLiveAsyncWithHttpInfo
     *
     * Live
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesLive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesLiveAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['leaguesLive'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportLeaguesLiveResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesLiveRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaguesLive'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesLive'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaguesLiveRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leaguesLive'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/leagues/live';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation leaguesSearch
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportLeaguesSearchResponse
     */
    public function leaguesSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesSearch'][0]

    )
    {

        list($response) = $this->leaguesSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation leaguesSearchWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportLeaguesSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaguesSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->leaguesSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportLeaguesSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportLeaguesSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportLeaguesSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportLeaguesSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportLeaguesSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaguesSearchAsync
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['leaguesSearch'][0]

    )
    {

        return $this->leaguesSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaguesSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaguesSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['leaguesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportLeaguesSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->leaguesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaguesSearch'
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaguesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaguesSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['leaguesSearch'][0])
    {

        // Check if $name is a string
        if ($name !== SENTINEL_VALUE && !is_string($name)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($name, true), gettype($name)));
        }
        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling leaguesSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/leagues/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation livescoresAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportLivescoresAllResponse
     */
    public function livescoresAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['livescoresAll'][0]

    )
    {

        list($response) = $this->livescoresAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation livescoresAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportLivescoresAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function livescoresAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['livescoresAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->livescoresAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->livescoresAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportLivescoresAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportLivescoresAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportLivescoresAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportLivescoresAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportLivescoresAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation livescoresAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function livescoresAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['livescoresAll'][0]

    )
    {

        return $this->livescoresAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation livescoresAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function livescoresAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['livescoresAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportLivescoresAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->livescoresAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'livescoresAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function livescoresAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['livescoresAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/livescores';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation livescoresAllInPlay
     *
     * All In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAllInPlay'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportLivescoresAllInPlayResponse
     */
    public function livescoresAllInPlay(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['livescoresAllInPlay'][0]

    )
    {

        list($response) = $this->livescoresAllInPlayWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation livescoresAllInPlayWithHttpInfo
     *
     * All In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAllInPlay'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportLivescoresAllInPlayResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function livescoresAllInPlayWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['livescoresAllInPlay'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->livescoresAllInPlayRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->livescoresAllInPlayWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportLivescoresAllInPlayResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportLivescoresAllInPlayResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportLivescoresAllInPlayResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportLivescoresAllInPlayResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportLivescoresAllInPlayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation livescoresAllInPlayAsync
     *
     * All In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAllInPlay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function livescoresAllInPlayAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['livescoresAllInPlay'][0]

    )
    {

        return $this->livescoresAllInPlayAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation livescoresAllInPlayAsyncWithHttpInfo
     *
     * All In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAllInPlay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function livescoresAllInPlayAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['livescoresAllInPlay'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportLivescoresAllInPlayResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->livescoresAllInPlayRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'livescoresAllInPlay'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresAllInPlay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function livescoresAllInPlayRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['livescoresAllInPlay'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/livescores/inplay';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation livescoresLatest
     *
     * Last Updated In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportLivescoresLatestResponse
     */
    public function livescoresLatest(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['livescoresLatest'][0]

    )
    {

        list($response) = $this->livescoresLatestWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation livescoresLatestWithHttpInfo
     *
     * Last Updated In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportLivescoresLatestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function livescoresLatestWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['livescoresLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->livescoresLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->livescoresLatestWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportLivescoresLatestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportLivescoresLatestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportLivescoresLatestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportLivescoresLatestResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportLivescoresLatestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation livescoresLatestAsync
     *
     * Last Updated In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function livescoresLatestAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['livescoresLatest'][0]

    )
    {

        return $this->livescoresLatestAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation livescoresLatestAsyncWithHttpInfo
     *
     * Last Updated In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function livescoresLatestAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['livescoresLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportLivescoresLatestResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->livescoresLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'livescoresLatest'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['livescoresLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function livescoresLatestRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['livescoresLatest'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/livescores/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation newsAllPostMatch
     *
     * All Post Match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPostMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function newsAllPostMatch(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsAllPostMatch'][0]

    )
    {

        list($response) = $this->newsAllPostMatchWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation newsAllPostMatchWithHttpInfo
     *
     * All Post Match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPostMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function newsAllPostMatchWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['newsAllPostMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsAllPostMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->newsAllPostMatchWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newsAllPostMatchAsync
     *
     * All Post Match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPostMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsAllPostMatchAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsAllPostMatch'][0]

    )
    {

        return $this->newsAllPostMatchAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newsAllPostMatchAsyncWithHttpInfo
     *
     * All Post Match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPostMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsAllPostMatchAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['newsAllPostMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'string';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsAllPostMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newsAllPostMatch'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPostMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newsAllPostMatchRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['newsAllPostMatch'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/news/post-match';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation newsAllPreMatch
     *
     * All Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportNewsAllPreMatchResponse
     */
    public function newsAllPreMatch(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsAllPreMatch'][0]

    )
    {

        list($response) = $this->newsAllPreMatchWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation newsAllPreMatchWithHttpInfo
     *
     * All Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportNewsAllPreMatchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function newsAllPreMatchWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['newsAllPreMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsAllPreMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->newsAllPreMatchWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportNewsAllPreMatchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportNewsAllPreMatchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportNewsAllPreMatchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportNewsAllPreMatchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportNewsAllPreMatchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newsAllPreMatchAsync
     *
     * All Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsAllPreMatchAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsAllPreMatch'][0]

    )
    {

        return $this->newsAllPreMatchAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newsAllPreMatchAsyncWithHttpInfo
     *
     * All Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsAllPreMatchAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['newsAllPreMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportNewsAllPreMatchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsAllPreMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newsAllPreMatch'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newsAllPreMatchRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['newsAllPreMatch'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/news/pre-match';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation newsPostMatchBySeasonId
     *
     * Post Match by Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPostMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function newsPostMatchBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsPostMatchBySeasonId'][0]

    )
    {

        list($response) = $this->newsPostMatchBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation newsPostMatchBySeasonIdWithHttpInfo
     *
     * Post Match by Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPostMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function newsPostMatchBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['newsPostMatchBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsPostMatchBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->newsPostMatchBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newsPostMatchBySeasonIdAsync
     *
     * Post Match by Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPostMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsPostMatchBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsPostMatchBySeasonId'][0]

    )
    {

        return $this->newsPostMatchBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newsPostMatchBySeasonIdAsyncWithHttpInfo
     *
     * Post Match by Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPostMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsPostMatchBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['newsPostMatchBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'string';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsPostMatchBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newsPostMatchBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPostMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newsPostMatchBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['newsPostMatchBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling newsPostMatchBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/news/post-match/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation newsPreMatchBySeasonId
     *
     * Pre-match By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPreMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportNewsPreMatchBySeasonIdResponse
     */
    public function newsPreMatchBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsPreMatchBySeasonId'][0]

    )
    {

        list($response) = $this->newsPreMatchBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation newsPreMatchBySeasonIdWithHttpInfo
     *
     * Pre-match By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPreMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportNewsPreMatchBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function newsPreMatchBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['newsPreMatchBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsPreMatchBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->newsPreMatchBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportNewsPreMatchBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportNewsPreMatchBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportNewsPreMatchBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportNewsPreMatchBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportNewsPreMatchBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newsPreMatchBySeasonIdAsync
     *
     * Pre-match By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPreMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsPreMatchBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsPreMatchBySeasonId'][0]

    )
    {

        return $this->newsPreMatchBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newsPreMatchBySeasonIdAsyncWithHttpInfo
     *
     * Pre-match By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPreMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsPreMatchBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['newsPreMatchBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportNewsPreMatchBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsPreMatchBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newsPreMatchBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve post-match news from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsPreMatchBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newsPreMatchBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['newsPreMatchBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling newsPreMatchBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/news/pre-match/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation newsUpcomingPostMatch
     *
     * Upcoming Post Match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPostMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function newsUpcomingPostMatch(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsUpcomingPostMatch'][0]

    )
    {

        list($response) = $this->newsUpcomingPostMatchWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation newsUpcomingPostMatchWithHttpInfo
     *
     * Upcoming Post Match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPostMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function newsUpcomingPostMatchWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['newsUpcomingPostMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsUpcomingPostMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->newsUpcomingPostMatchWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newsUpcomingPostMatchAsync
     *
     * Upcoming Post Match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPostMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsUpcomingPostMatchAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsUpcomingPostMatch'][0]

    )
    {

        return $this->newsUpcomingPostMatchAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newsUpcomingPostMatchAsyncWithHttpInfo
     *
     * Upcoming Post Match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPostMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsUpcomingPostMatchAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['newsUpcomingPostMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'string';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsUpcomingPostMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newsUpcomingPostMatch'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPostMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newsUpcomingPostMatchRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['newsUpcomingPostMatch'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/news/post-match/upcoming';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation newsUpcomingPreMatch
     *
     * Upcoming Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPreMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportNewsUpcomingPreMatchResponse
     */
    public function newsUpcomingPreMatch(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsUpcomingPreMatch'][0]

    )
    {

        list($response) = $this->newsUpcomingPreMatchWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation newsUpcomingPreMatchWithHttpInfo
     *
     * Upcoming Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPreMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportNewsUpcomingPreMatchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function newsUpcomingPreMatchWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['newsUpcomingPreMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsUpcomingPreMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->newsUpcomingPreMatchWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportNewsUpcomingPreMatchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportNewsUpcomingPreMatchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportNewsUpcomingPreMatchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportNewsUpcomingPreMatchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportNewsUpcomingPreMatchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newsUpcomingPreMatchAsync
     *
     * Upcoming Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsUpcomingPreMatchAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['newsUpcomingPreMatch'][0]

    )
    {

        return $this->newsUpcomingPreMatchAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newsUpcomingPreMatchAsyncWithHttpInfo
     *
     * Upcoming Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsUpcomingPreMatchAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['newsUpcomingPreMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportNewsUpcomingPreMatchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->newsUpcomingPreMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newsUpcomingPreMatch'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newsUpcomingPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newsUpcomingPreMatchRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['newsUpcomingPreMatch'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/news/pre-match/upcoming';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsAllInPlay
     *
     * All In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllInPlay'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportOddsAllInPlayResponse
     */
    public function oddsAllInPlay(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsAllInPlay'][0]

    )
    {

        list($response) = $this->oddsAllInPlayWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsAllInPlayWithHttpInfo
     *
     * All In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllInPlay'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportOddsAllInPlayResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsAllInPlayWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['oddsAllInPlay'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsAllInPlayRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsAllInPlayWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportOddsAllInPlayResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportOddsAllInPlayResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportOddsAllInPlayResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportOddsAllInPlayResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportOddsAllInPlayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsAllInPlayAsync
     *
     * All In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllInPlay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsAllInPlayAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsAllInPlay'][0]

    )
    {

        return $this->oddsAllInPlayAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsAllInPlayAsyncWithHttpInfo
     *
     * All In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllInPlay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsAllInPlayAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['oddsAllInPlay'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportOddsAllInPlayResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsAllInPlayRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsAllInPlay'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllInPlay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsAllInPlayRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsAllInPlay'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/inplay';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsAllPreMatch
     *
     * All Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportOddsAllPreMatchResponse
     */
    public function oddsAllPreMatch(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsAllPreMatch'][0]

    )
    {

        list($response) = $this->oddsAllPreMatchWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsAllPreMatchWithHttpInfo
     *
     * All Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportOddsAllPreMatchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsAllPreMatchWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['oddsAllPreMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsAllPreMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsAllPreMatchWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportOddsAllPreMatchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportOddsAllPreMatchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportOddsAllPreMatchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportOddsAllPreMatchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportOddsAllPreMatchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsAllPreMatchAsync
     *
     * All Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsAllPreMatchAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsAllPreMatch'][0]

    )
    {

        return $this->oddsAllPreMatchAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsAllPreMatchAsyncWithHttpInfo
     *
     * All Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsAllPreMatchAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['oddsAllPreMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportOddsAllPreMatchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsAllPreMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsAllPreMatch'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsAllPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsAllPreMatchRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsAllPreMatch'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/pre-match';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsInPlayByFixtureAndBookmakerId
     *
     * In-play by Fixture and Bookmaker ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function oddsInPlayByFixtureAndBookmakerId(
        $fixture_id,
        $bookmaker_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsInPlayByFixtureAndBookmakerId'][0]

    )
    {

        list($response) = $this->oddsInPlayByFixtureAndBookmakerIdWithHttpInfo($fixture_id, $bookmaker_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsInPlayByFixtureAndBookmakerIdWithHttpInfo
     *
     * In-play by Fixture and Bookmaker ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsInPlayByFixtureAndBookmakerIdWithHttpInfo($fixture_id, $bookmaker_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsInPlayByFixtureAndBookmakerId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsInPlayByFixtureAndBookmakerIdRequest($fixture_id, $bookmaker_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsInPlayByFixtureAndBookmakerIdWithHttpInfo(
                        $fixture_id,
                        $bookmaker_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsInPlayByFixtureAndBookmakerIdAsync
     *
     * In-play by Fixture and Bookmaker ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsInPlayByFixtureAndBookmakerIdAsync(
        $fixture_id,
        $bookmaker_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsInPlayByFixtureAndBookmakerId'][0]

    )
    {

        return $this->oddsInPlayByFixtureAndBookmakerIdAsyncWithHttpInfo($fixture_id, $bookmaker_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsInPlayByFixtureAndBookmakerIdAsyncWithHttpInfo
     *
     * In-play by Fixture and Bookmaker ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsInPlayByFixtureAndBookmakerIdAsyncWithHttpInfo($fixture_id, $bookmaker_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsInPlayByFixtureAndBookmakerId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsInPlayByFixtureAndBookmakerIdRequest($fixture_id, $bookmaker_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsInPlayByFixtureAndBookmakerId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsInPlayByFixtureAndBookmakerIdRequest($fixture_id, $bookmaker_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsInPlayByFixtureAndBookmakerId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling oddsInPlayByFixtureAndBookmakerId'
            );
        }
        // verify the required parameter 'bookmaker_id' is set
        if ($bookmaker_id === SENTINEL_VALUE || (is_array($bookmaker_id) && count($bookmaker_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter bookmaker_id when calling oddsInPlayByFixtureAndBookmakerId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/inplay/fixtures/{fixtureId}/bookmakers/{bookmakerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }
        // path params
        if ($bookmaker_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'bookmakerId' . '}',
                ObjectSerializer::toPathValue($bookmaker_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsInPlayByFixtureAndMarketId
     *
     * In-play by Fixture and Market ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function oddsInPlayByFixtureAndMarketId(
        $fixture_id,
        $market_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsInPlayByFixtureAndMarketId'][0]

    )
    {

        list($response) = $this->oddsInPlayByFixtureAndMarketIdWithHttpInfo($fixture_id, $market_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsInPlayByFixtureAndMarketIdWithHttpInfo
     *
     * In-play by Fixture and Market ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsInPlayByFixtureAndMarketIdWithHttpInfo($fixture_id, $market_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsInPlayByFixtureAndMarketId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsInPlayByFixtureAndMarketIdRequest($fixture_id, $market_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsInPlayByFixtureAndMarketIdWithHttpInfo(
                        $fixture_id,
                        $market_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsInPlayByFixtureAndMarketIdAsync
     *
     * In-play by Fixture and Market ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsInPlayByFixtureAndMarketIdAsync(
        $fixture_id,
        $market_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsInPlayByFixtureAndMarketId'][0]

    )
    {

        return $this->oddsInPlayByFixtureAndMarketIdAsyncWithHttpInfo($fixture_id, $market_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsInPlayByFixtureAndMarketIdAsyncWithHttpInfo
     *
     * In-play by Fixture and Market ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsInPlayByFixtureAndMarketIdAsyncWithHttpInfo($fixture_id, $market_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsInPlayByFixtureAndMarketId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsInPlayByFixtureAndMarketIdRequest($fixture_id, $market_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsInPlayByFixtureAndMarketId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsInPlayByFixtureAndMarketIdRequest($fixture_id, $market_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsInPlayByFixtureAndMarketId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling oddsInPlayByFixtureAndMarketId'
            );
        }
        // verify the required parameter 'market_id' is set
        if ($market_id === SENTINEL_VALUE || (is_array($market_id) && count($market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter market_id when calling oddsInPlayByFixtureAndMarketId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/inplay/fixtures/{fixtureId}/markets/{marketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsInPlayByFixtureId
     *
     * In-play by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportOddsInPlayByFixtureIdResponse
     */
    public function oddsInPlayByFixtureId(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsInPlayByFixtureId'][0]

    )
    {

        list($response) = $this->oddsInPlayByFixtureIdWithHttpInfo($fixture_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsInPlayByFixtureIdWithHttpInfo
     *
     * In-play by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportOddsInPlayByFixtureIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsInPlayByFixtureIdWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsInPlayByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsInPlayByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsInPlayByFixtureIdWithHttpInfo(
                        $fixture_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportOddsInPlayByFixtureIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportOddsInPlayByFixtureIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportOddsInPlayByFixtureIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportOddsInPlayByFixtureIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportOddsInPlayByFixtureIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsInPlayByFixtureIdAsync
     *
     * In-play by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsInPlayByFixtureIdAsync(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsInPlayByFixtureId'][0]

    )
    {

        return $this->oddsInPlayByFixtureIdAsyncWithHttpInfo($fixture_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsInPlayByFixtureIdAsyncWithHttpInfo
     *
     * In-play by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsInPlayByFixtureIdAsyncWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsInPlayByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportOddsInPlayByFixtureIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsInPlayByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsInPlayByFixtureId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve in-play odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsInPlayByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsInPlayByFixtureIdRequest($fixture_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsInPlayByFixtureId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling oddsInPlayByFixtureId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/inplay/fixtures/{fixtureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsLatestInPlay
     *
     * Latest In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestInPlay'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function oddsLatestInPlay(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsLatestInPlay'][0]

    )
    {

        list($response) = $this->oddsLatestInPlayWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsLatestInPlayWithHttpInfo
     *
     * Latest In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestInPlay'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsLatestInPlayWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['oddsLatestInPlay'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsLatestInPlayRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsLatestInPlayWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsLatestInPlayAsync
     *
     * Latest In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestInPlay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsLatestInPlayAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsLatestInPlay'][0]

    )
    {

        return $this->oddsLatestInPlayAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsLatestInPlayAsyncWithHttpInfo
     *
     * Latest In-play
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestInPlay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsLatestInPlayAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['oddsLatestInPlay'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsLatestInPlayRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsLatestInPlay'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestInPlay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsLatestInPlayRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsLatestInPlay'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/inplay/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsLatestPreMatch
     *
     * Last Updated Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestPreMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function oddsLatestPreMatch(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsLatestPreMatch'][0]

    )
    {

        list($response) = $this->oddsLatestPreMatchWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsLatestPreMatchWithHttpInfo
     *
     * Last Updated Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestPreMatch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsLatestPreMatchWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['oddsLatestPreMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsLatestPreMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsLatestPreMatchWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsLatestPreMatchAsync
     *
     * Last Updated Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsLatestPreMatchAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsLatestPreMatch'][0]

    )
    {

        return $this->oddsLatestPreMatchAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsLatestPreMatchAsyncWithHttpInfo
     *
     * Last Updated Pre-match
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsLatestPreMatchAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['oddsLatestPreMatch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsLatestPreMatchRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsLatestPreMatch'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsLatestPreMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsLatestPreMatchRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsLatestPreMatch'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/pre-match/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsPreMatchByFixtureAndBookmakerId
     *
     * Pre-match by Fixture and Bookmaker ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportOddsPreMatchByFixtureAndBookmakerIdResponse
     */
    public function oddsPreMatchByFixtureAndBookmakerId(
        $fixture_id,
        $bookmaker_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'][0]

    )
    {

        list($response) = $this->oddsPreMatchByFixtureAndBookmakerIdWithHttpInfo($fixture_id, $bookmaker_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsPreMatchByFixtureAndBookmakerIdWithHttpInfo
     *
     * Pre-match by Fixture and Bookmaker ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportOddsPreMatchByFixtureAndBookmakerIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsPreMatchByFixtureAndBookmakerIdWithHttpInfo($fixture_id, $bookmaker_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsPreMatchByFixtureAndBookmakerIdRequest($fixture_id, $bookmaker_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsPreMatchByFixtureAndBookmakerIdWithHttpInfo(
                        $fixture_id,
                        $bookmaker_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportOddsPreMatchByFixtureAndBookmakerIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportOddsPreMatchByFixtureAndBookmakerIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportOddsPreMatchByFixtureAndBookmakerIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportOddsPreMatchByFixtureAndBookmakerIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportOddsPreMatchByFixtureAndBookmakerIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsPreMatchByFixtureAndBookmakerIdAsync
     *
     * Pre-match by Fixture and Bookmaker ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsPreMatchByFixtureAndBookmakerIdAsync(
        $fixture_id,
        $bookmaker_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'][0]

    )
    {

        return $this->oddsPreMatchByFixtureAndBookmakerIdAsyncWithHttpInfo($fixture_id, $bookmaker_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsPreMatchByFixtureAndBookmakerIdAsyncWithHttpInfo
     *
     * Pre-match by Fixture and Bookmaker ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsPreMatchByFixtureAndBookmakerIdAsyncWithHttpInfo($fixture_id, $bookmaker_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportOddsPreMatchByFixtureAndBookmakerIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsPreMatchByFixtureAndBookmakerIdRequest($fixture_id, $bookmaker_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsPreMatchByFixtureAndBookmakerId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $bookmaker_id The ID of the bookmaker you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsPreMatchByFixtureAndBookmakerIdRequest($fixture_id, $bookmaker_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsPreMatchByFixtureAndBookmakerId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling oddsPreMatchByFixtureAndBookmakerId'
            );
        }
        // verify the required parameter 'bookmaker_id' is set
        if ($bookmaker_id === SENTINEL_VALUE || (is_array($bookmaker_id) && count($bookmaker_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter bookmaker_id when calling oddsPreMatchByFixtureAndBookmakerId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/pre-match/fixtures/{fixtureId}/bookmakers/{bookmakerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }
        // path params
        if ($bookmaker_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'bookmakerId' . '}',
                ObjectSerializer::toPathValue($bookmaker_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsPreMatchByFixtureAndMarketId
     *
     * Pre-match by Fixture and Market ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportOddsPreMatchByFixtureAndMarketIdResponse
     */
    public function oddsPreMatchByFixtureAndMarketId(
        $fixture_id,
        $market_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsPreMatchByFixtureAndMarketId'][0]

    )
    {

        list($response) = $this->oddsPreMatchByFixtureAndMarketIdWithHttpInfo($fixture_id, $market_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsPreMatchByFixtureAndMarketIdWithHttpInfo
     *
     * Pre-match by Fixture and Market ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportOddsPreMatchByFixtureAndMarketIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsPreMatchByFixtureAndMarketIdWithHttpInfo($fixture_id, $market_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsPreMatchByFixtureAndMarketId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsPreMatchByFixtureAndMarketIdRequest($fixture_id, $market_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsPreMatchByFixtureAndMarketIdWithHttpInfo(
                        $fixture_id,
                        $market_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportOddsPreMatchByFixtureAndMarketIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportOddsPreMatchByFixtureAndMarketIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportOddsPreMatchByFixtureAndMarketIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportOddsPreMatchByFixtureAndMarketIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportOddsPreMatchByFixtureAndMarketIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsPreMatchByFixtureAndMarketIdAsync
     *
     * Pre-match by Fixture and Market ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsPreMatchByFixtureAndMarketIdAsync(
        $fixture_id,
        $market_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsPreMatchByFixtureAndMarketId'][0]

    )
    {

        return $this->oddsPreMatchByFixtureAndMarketIdAsyncWithHttpInfo($fixture_id, $market_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsPreMatchByFixtureAndMarketIdAsyncWithHttpInfo
     *
     * Pre-match by Fixture and Market ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsPreMatchByFixtureAndMarketIdAsyncWithHttpInfo($fixture_id, $market_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsPreMatchByFixtureAndMarketId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportOddsPreMatchByFixtureAndMarketIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsPreMatchByFixtureAndMarketIdRequest($fixture_id, $market_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsPreMatchByFixtureAndMarketId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  int $market_id The ID of the market you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureAndMarketId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsPreMatchByFixtureAndMarketIdRequest($fixture_id, $market_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsPreMatchByFixtureAndMarketId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling oddsPreMatchByFixtureAndMarketId'
            );
        }
        // verify the required parameter 'market_id' is set
        if ($market_id === SENTINEL_VALUE || (is_array($market_id) && count($market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter market_id when calling oddsPreMatchByFixtureAndMarketId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/pre-match/fixtures/{fixtureId}/markets/{marketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation oddsPreMatchByFixtureId
     *
     * Pre-match by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportOddsPreMatchByFixtureIdResponse
     */
    public function oddsPreMatchByFixtureId(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsPreMatchByFixtureId'][0]

    )
    {

        list($response) = $this->oddsPreMatchByFixtureIdWithHttpInfo($fixture_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation oddsPreMatchByFixtureIdWithHttpInfo
     *
     * Pre-match by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportOddsPreMatchByFixtureIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function oddsPreMatchByFixtureIdWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsPreMatchByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsPreMatchByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->oddsPreMatchByFixtureIdWithHttpInfo(
                        $fixture_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportOddsPreMatchByFixtureIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportOddsPreMatchByFixtureIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportOddsPreMatchByFixtureIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportOddsPreMatchByFixtureIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportOddsPreMatchByFixtureIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation oddsPreMatchByFixtureIdAsync
     *
     * Pre-match by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsPreMatchByFixtureIdAsync(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['oddsPreMatchByFixtureId'][0]

    )
    {

        return $this->oddsPreMatchByFixtureIdAsyncWithHttpInfo($fixture_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation oddsPreMatchByFixtureIdAsyncWithHttpInfo
     *
     * Pre-match by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function oddsPreMatchByFixtureIdAsyncWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['oddsPreMatchByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportOddsPreMatchByFixtureIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->oddsPreMatchByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'oddsPreMatchByFixtureId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve pre-match odds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['oddsPreMatchByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function oddsPreMatchByFixtureIdRequest($fixture_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['oddsPreMatchByFixtureId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling oddsPreMatchByFixtureId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/odds/pre-match/fixtures/{fixtureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation playerById
     *
     * By ID
     *
     * @param  int $player_id The ID of the player you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportPlayerByIdResponse
     */
    public function playerById(
        $player_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playerById'][0]

    )
    {

        list($response) = $this->playerByIdWithHttpInfo($player_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation playerByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $player_id The ID of the player you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportPlayerByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function playerByIdWithHttpInfo($player_id, $version = null, $sport = null, string $contentType = self::contentTypes['playerById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playerByIdRequest($player_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->playerByIdWithHttpInfo(
                        $player_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportPlayerByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportPlayerByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportPlayerByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportPlayerByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportPlayerByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation playerByIdAsync
     *
     * By ID
     *
     * @param  int $player_id The ID of the player you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playerByIdAsync(
        $player_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playerById'][0]

    )
    {

        return $this->playerByIdAsyncWithHttpInfo($player_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playerByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $player_id The ID of the player you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playerByIdAsyncWithHttpInfo($player_id, $version = null, $sport = null, string $contentType = self::contentTypes['playerById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportPlayerByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playerByIdRequest($player_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playerById'
     *
     * @param  int $player_id The ID of the player you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playerByIdRequest($player_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['playerById'][0])
    {

        // verify the required parameter 'player_id' is set
        if ($player_id === SENTINEL_VALUE || (is_array($player_id) && count($player_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter player_id when calling playerById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/players/{playerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($player_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'playerId' . '}',
                ObjectSerializer::toPathValue($player_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation playersAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportPlayersAllResponse
     */
    public function playersAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playersAll'][0]

    )
    {

        list($response) = $this->playersAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation playersAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportPlayersAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function playersAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['playersAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playersAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->playersAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportPlayersAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportPlayersAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportPlayersAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportPlayersAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportPlayersAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation playersAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playersAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playersAll'][0]

    )
    {

        return $this->playersAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playersAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playersAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['playersAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportPlayersAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playersAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playersAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playersAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['playersAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/players';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation playersByCountryId
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve players from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportPlayersByCountryIdResponse
     */
    public function playersByCountryId(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playersByCountryId'][0]

    )
    {

        list($response) = $this->playersByCountryIdWithHttpInfo($country_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation playersByCountryIdWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve players from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportPlayersByCountryIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function playersByCountryIdWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['playersByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playersByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->playersByCountryIdWithHttpInfo(
                        $country_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportPlayersByCountryIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportPlayersByCountryIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportPlayersByCountryIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportPlayersByCountryIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportPlayersByCountryIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation playersByCountryIdAsync
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve players from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playersByCountryIdAsync(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playersByCountryId'][0]

    )
    {

        return $this->playersByCountryIdAsyncWithHttpInfo($country_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playersByCountryIdAsyncWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve players from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playersByCountryIdAsyncWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['playersByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportPlayersByCountryIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playersByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playersByCountryId'
     *
     * @param  int $country_id The ID of the country you want to retrieve players from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playersByCountryIdRequest($country_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['playersByCountryId'][0])
    {

        // verify the required parameter 'country_id' is set
        if ($country_id === SENTINEL_VALUE || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter country_id when calling playersByCountryId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/players/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation playersLatest
     *
     * Latest Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportPlayersLatestResponse
     */
    public function playersLatest(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playersLatest'][0]

    )
    {

        list($response) = $this->playersLatestWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation playersLatestWithHttpInfo
     *
     * Latest Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportPlayersLatestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function playersLatestWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['playersLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playersLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->playersLatestWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportPlayersLatestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportPlayersLatestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportPlayersLatestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportPlayersLatestResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportPlayersLatestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation playersLatestAsync
     *
     * Latest Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playersLatestAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playersLatest'][0]

    )
    {

        return $this->playersLatestAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playersLatestAsyncWithHttpInfo
     *
     * Latest Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playersLatestAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['playersLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportPlayersLatestResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playersLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playersLatest'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playersLatestRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['playersLatest'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/players/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation playersSearch
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportPlayersSearchResponse
     */
    public function playersSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playersSearch'][0]

    )
    {

        list($response) = $this->playersSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation playersSearchWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportPlayersSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function playersSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['playersSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playersSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->playersSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportPlayersSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportPlayersSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportPlayersSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportPlayersSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportPlayersSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation playersSearchAsync
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playersSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['playersSearch'][0]

    )
    {

        return $this->playersSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playersSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playersSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['playersSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportPlayersSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->playersSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playersSearch'
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playersSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playersSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['playersSearch'][0])
    {

        // Check if $name is a string
        if ($name !== SENTINEL_VALUE && !is_string($name)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($name, true), gettype($name)));
        }
        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling playersSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/players/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation predictionsAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportPredictionsAllResponse
     */
    public function predictionsAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['predictionsAll'][0]

    )
    {

        list($response) = $this->predictionsAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation predictionsAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportPredictionsAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function predictionsAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['predictionsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->predictionsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->predictionsAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportPredictionsAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportPredictionsAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportPredictionsAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportPredictionsAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportPredictionsAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation predictionsAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function predictionsAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['predictionsAll'][0]

    )
    {

        return $this->predictionsAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation predictionsAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function predictionsAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['predictionsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportPredictionsAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->predictionsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'predictionsAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function predictionsAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['predictionsAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/predictions/probabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation predictionsAllValueBets
     *
     * All Value Bets
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAllValueBets'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportPredictionsAllValueBetsResponse
     */
    public function predictionsAllValueBets(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['predictionsAllValueBets'][0]

    )
    {

        list($response) = $this->predictionsAllValueBetsWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation predictionsAllValueBetsWithHttpInfo
     *
     * All Value Bets
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAllValueBets'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportPredictionsAllValueBetsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function predictionsAllValueBetsWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['predictionsAllValueBets'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->predictionsAllValueBetsRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->predictionsAllValueBetsWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportPredictionsAllValueBetsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportPredictionsAllValueBetsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportPredictionsAllValueBetsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportPredictionsAllValueBetsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportPredictionsAllValueBetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation predictionsAllValueBetsAsync
     *
     * All Value Bets
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAllValueBets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function predictionsAllValueBetsAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['predictionsAllValueBets'][0]

    )
    {

        return $this->predictionsAllValueBetsAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation predictionsAllValueBetsAsyncWithHttpInfo
     *
     * All Value Bets
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAllValueBets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function predictionsAllValueBetsAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['predictionsAllValueBets'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportPredictionsAllValueBetsResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->predictionsAllValueBetsRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'predictionsAllValueBets'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsAllValueBets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function predictionsAllValueBetsRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['predictionsAllValueBets'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/predictions/value-bets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation predictionsByFixtureId
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve predictions from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportPredictionsByFixtureIdResponse
     */
    public function predictionsByFixtureId(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['predictionsByFixtureId'][0]

    )
    {

        list($response) = $this->predictionsByFixtureIdWithHttpInfo($fixture_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation predictionsByFixtureIdWithHttpInfo
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve predictions from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportPredictionsByFixtureIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function predictionsByFixtureIdWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['predictionsByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->predictionsByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->predictionsByFixtureIdWithHttpInfo(
                        $fixture_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportPredictionsByFixtureIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportPredictionsByFixtureIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportPredictionsByFixtureIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportPredictionsByFixtureIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportPredictionsByFixtureIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation predictionsByFixtureIdAsync
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve predictions from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function predictionsByFixtureIdAsync(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['predictionsByFixtureId'][0]

    )
    {

        return $this->predictionsByFixtureIdAsyncWithHttpInfo($fixture_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation predictionsByFixtureIdAsyncWithHttpInfo
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve predictions from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function predictionsByFixtureIdAsyncWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['predictionsByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportPredictionsByFixtureIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->predictionsByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'predictionsByFixtureId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve predictions from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function predictionsByFixtureIdRequest($fixture_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['predictionsByFixtureId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling predictionsByFixtureId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/predictions/probabilities/fixtures/{fixtureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation predictionsValueBetsByFixtureId
     *
     * Value Bets by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve value bets from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsValueBetsByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function predictionsValueBetsByFixtureId(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['predictionsValueBetsByFixtureId'][0]

    )
    {

        list($response) = $this->predictionsValueBetsByFixtureIdWithHttpInfo($fixture_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation predictionsValueBetsByFixtureIdWithHttpInfo
     *
     * Value Bets by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve value bets from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsValueBetsByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function predictionsValueBetsByFixtureIdWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['predictionsValueBetsByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->predictionsValueBetsByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->predictionsValueBetsByFixtureIdWithHttpInfo(
                        $fixture_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation predictionsValueBetsByFixtureIdAsync
     *
     * Value Bets by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve value bets from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsValueBetsByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function predictionsValueBetsByFixtureIdAsync(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['predictionsValueBetsByFixtureId'][0]

    )
    {

        return $this->predictionsValueBetsByFixtureIdAsyncWithHttpInfo($fixture_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation predictionsValueBetsByFixtureIdAsyncWithHttpInfo
     *
     * Value Bets by Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve value bets from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsValueBetsByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function predictionsValueBetsByFixtureIdAsyncWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['predictionsValueBetsByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->predictionsValueBetsByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'predictionsValueBetsByFixtureId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve value bets from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['predictionsValueBetsByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function predictionsValueBetsByFixtureIdRequest($fixture_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['predictionsValueBetsByFixtureId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling predictionsValueBetsByFixtureId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/predictions/value-bets/fixtures/{fixtureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation refereeById
     *
     * By ID
     *
     * @param  int $referee_id The ID of the referee you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereeById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRefereeByIdResponse
     */
    public function refereeById(
        $referee_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereeById'][0]

    )
    {

        list($response) = $this->refereeByIdWithHttpInfo($referee_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation refereeByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $referee_id The ID of the referee you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereeById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRefereeByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function refereeByIdWithHttpInfo($referee_id, $version = null, $sport = null, string $contentType = self::contentTypes['refereeById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereeByIdRequest($referee_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->refereeByIdWithHttpInfo(
                        $referee_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportRefereeByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRefereeByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRefereeByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRefereeByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRefereeByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refereeByIdAsync
     *
     * By ID
     *
     * @param  int $referee_id The ID of the referee you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereeById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereeByIdAsync(
        $referee_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereeById'][0]

    )
    {

        return $this->refereeByIdAsyncWithHttpInfo($referee_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refereeByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $referee_id The ID of the referee you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereeById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereeByIdAsyncWithHttpInfo($referee_id, $version = null, $sport = null, string $contentType = self::contentTypes['refereeById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRefereeByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereeByIdRequest($referee_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refereeById'
     *
     * @param  int $referee_id The ID of the referee you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereeById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refereeByIdRequest($referee_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['refereeById'][0])
    {

        // verify the required parameter 'referee_id' is set
        if ($referee_id === SENTINEL_VALUE || (is_array($referee_id) && count($referee_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter referee_id when calling refereeById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/referees/{refereeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($referee_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'refereeId' . '}',
                ObjectSerializer::toPathValue($referee_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation refereesAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRefereesAllResponse
     */
    public function refereesAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereesAll'][0]

    )
    {

        list($response) = $this->refereesAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation refereesAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRefereesAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function refereesAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['refereesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->refereesAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportRefereesAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRefereesAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRefereesAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRefereesAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRefereesAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refereesAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereesAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereesAll'][0]

    )
    {

        return $this->refereesAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refereesAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereesAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['refereesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRefereesAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refereesAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refereesAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['refereesAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/referees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation refereesByCountryId
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRefereesByCountryIdResponse
     */
    public function refereesByCountryId(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereesByCountryId'][0]

    )
    {

        list($response) = $this->refereesByCountryIdWithHttpInfo($country_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation refereesByCountryIdWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRefereesByCountryIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function refereesByCountryIdWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['refereesByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereesByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->refereesByCountryIdWithHttpInfo(
                        $country_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportRefereesByCountryIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRefereesByCountryIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRefereesByCountryIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRefereesByCountryIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRefereesByCountryIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refereesByCountryIdAsync
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereesByCountryIdAsync(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereesByCountryId'][0]

    )
    {

        return $this->refereesByCountryIdAsyncWithHttpInfo($country_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refereesByCountryIdAsyncWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereesByCountryIdAsyncWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['refereesByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRefereesByCountryIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereesByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refereesByCountryId'
     *
     * @param  int $country_id The ID of the country you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refereesByCountryIdRequest($country_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['refereesByCountryId'][0])
    {

        // verify the required parameter 'country_id' is set
        if ($country_id === SENTINEL_VALUE || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter country_id when calling refereesByCountryId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/referees/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation refereesBySeasonId
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRefereesBySeasonIdResponse
     */
    public function refereesBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereesBySeasonId'][0]

    )
    {

        list($response) = $this->refereesBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation refereesBySeasonIdWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRefereesBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function refereesBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['refereesBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereesBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->refereesBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportRefereesBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRefereesBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRefereesBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRefereesBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRefereesBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refereesBySeasonIdAsync
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereesBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereesBySeasonId'][0]

    )
    {

        return $this->refereesBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refereesBySeasonIdAsyncWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereesBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['refereesBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRefereesBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereesBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refereesBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve referees from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refereesBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['refereesBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling refereesBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/referees/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation refereesSearch
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRefereesSearchResponse
     */
    public function refereesSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereesSearch'][0]

    )
    {

        list($response) = $this->refereesSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation refereesSearchWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRefereesSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function refereesSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['refereesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->refereesSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportRefereesSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRefereesSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRefereesSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRefereesSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRefereesSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refereesSearchAsync
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereesSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['refereesSearch'][0]

    )
    {

        return $this->refereesSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refereesSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refereesSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['refereesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRefereesSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->refereesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refereesSearch'
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refereesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refereesSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['refereesSearch'][0])
    {

        // Check if $name is a string
        if ($name !== SENTINEL_VALUE && !is_string($name)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($name, true), gettype($name)));
        }
        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling refereesSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/referees/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation rivalsAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRivalsAllResponse
     */
    public function rivalsAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['rivalsAll'][0]

    )
    {

        list($response) = $this->rivalsAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation rivalsAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRivalsAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function rivalsAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['rivalsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->rivalsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->rivalsAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportRivalsAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRivalsAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRivalsAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRivalsAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRivalsAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rivalsAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rivalsAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['rivalsAll'][0]

    )
    {

        return $this->rivalsAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rivalsAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rivalsAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['rivalsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRivalsAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->rivalsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rivalsAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function rivalsAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['rivalsAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/rivals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation rivalsByTeamId
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve rivals from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRivalsByTeamIdResponse
     */
    public function rivalsByTeamId(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['rivalsByTeamId'][0]

    )
    {

        list($response) = $this->rivalsByTeamIdWithHttpInfo($team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation rivalsByTeamIdWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve rivals from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRivalsByTeamIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function rivalsByTeamIdWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['rivalsByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->rivalsByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->rivalsByTeamIdWithHttpInfo(
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportRivalsByTeamIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRivalsByTeamIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRivalsByTeamIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRivalsByTeamIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRivalsByTeamIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rivalsByTeamIdAsync
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve rivals from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rivalsByTeamIdAsync(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['rivalsByTeamId'][0]

    )
    {

        return $this->rivalsByTeamIdAsyncWithHttpInfo($team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rivalsByTeamIdAsyncWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve rivals from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rivalsByTeamIdAsyncWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['rivalsByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRivalsByTeamIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->rivalsByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rivalsByTeamId'
     *
     * @param  int $team_id The ID of the team you want to retrieve rivals from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rivalsByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function rivalsByTeamIdRequest($team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['rivalsByTeamId'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling rivalsByTeamId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/rivals/teams/{teamId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation roundById
     *
     * By ID
     *
     * @param  int $round_id The ID of the round you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRoundByIdResponse
     */
    public function roundById(
        $round_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['roundById'][0]

    )
    {

        list($response) = $this->roundByIdWithHttpInfo($round_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation roundByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $round_id The ID of the round you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRoundByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function roundByIdWithHttpInfo($round_id, $version = null, $sport = null, string $contentType = self::contentTypes['roundById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->roundByIdRequest($round_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->roundByIdWithHttpInfo(
                        $round_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportRoundByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRoundByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRoundByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRoundByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRoundByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation roundByIdAsync
     *
     * By ID
     *
     * @param  int $round_id The ID of the round you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function roundByIdAsync(
        $round_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['roundById'][0]

    )
    {

        return $this->roundByIdAsyncWithHttpInfo($round_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation roundByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $round_id The ID of the round you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function roundByIdAsyncWithHttpInfo($round_id, $version = null, $sport = null, string $contentType = self::contentTypes['roundById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRoundByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->roundByIdRequest($round_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'roundById'
     *
     * @param  int $round_id The ID of the round you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function roundByIdRequest($round_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['roundById'][0])
    {

        // verify the required parameter 'round_id' is set
        if ($round_id === SENTINEL_VALUE || (is_array($round_id) && count($round_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter round_id when calling roundById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/rounds/{roundId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($round_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'roundId' . '}',
                ObjectSerializer::toPathValue($round_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation roundsAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRoundsAllResponse
     */
    public function roundsAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['roundsAll'][0]

    )
    {

        list($response) = $this->roundsAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation roundsAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRoundsAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function roundsAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['roundsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->roundsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->roundsAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportRoundsAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRoundsAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRoundsAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRoundsAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRoundsAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation roundsAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function roundsAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['roundsAll'][0]

    )
    {

        return $this->roundsAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation roundsAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function roundsAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['roundsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRoundsAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->roundsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'roundsAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function roundsAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['roundsAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/rounds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation roundsBySeasonId
     *
     * Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve rounds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRoundsBySeasonIdResponse
     */
    public function roundsBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['roundsBySeasonId'][0]

    )
    {

        list($response) = $this->roundsBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation roundsBySeasonIdWithHttpInfo
     *
     * Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve rounds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRoundsBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function roundsBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['roundsBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->roundsBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->roundsBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportRoundsBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRoundsBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRoundsBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRoundsBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRoundsBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation roundsBySeasonIdAsync
     *
     * Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve rounds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function roundsBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['roundsBySeasonId'][0]

    )
    {

        return $this->roundsBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation roundsBySeasonIdAsyncWithHttpInfo
     *
     * Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve rounds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function roundsBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['roundsBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRoundsBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->roundsBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'roundsBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve rounds from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function roundsBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['roundsBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling roundsBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/rounds/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation roundsSearch
     *
     * Search
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportRoundsSearchResponse
     */
    public function roundsSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['roundsSearch'][0]

    )
    {

        list($response) = $this->roundsSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation roundsSearchWithHttpInfo
     *
     * Search
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportRoundsSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function roundsSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['roundsSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->roundsSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->roundsSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportRoundsSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportRoundsSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportRoundsSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportRoundsSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportRoundsSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation roundsSearchAsync
     *
     * Search
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function roundsSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['roundsSearch'][0]

    )
    {

        return $this->roundsSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation roundsSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function roundsSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['roundsSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportRoundsSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->roundsSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'roundsSearch'
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['roundsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function roundsSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['roundsSearch'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling roundsSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/rounds/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation schedulesBySeasonId
     *
     * By Season ID
     *
     * @param  int $season_id season_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportSchedulesBySeasonIdResponse
     */
    public function schedulesBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['schedulesBySeasonId'][0]

    )
    {

        list($response) = $this->schedulesBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation schedulesBySeasonIdWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportSchedulesBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function schedulesBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['schedulesBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->schedulesBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->schedulesBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportSchedulesBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportSchedulesBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportSchedulesBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportSchedulesBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportSchedulesBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schedulesBySeasonIdAsync
     *
     * By Season ID
     *
     * @param  int $season_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schedulesBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['schedulesBySeasonId'][0]

    )
    {

        return $this->schedulesBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schedulesBySeasonIdAsyncWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schedulesBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['schedulesBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportSchedulesBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->schedulesBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schedulesBySeasonId'
     *
     * @param  int $season_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schedulesBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['schedulesBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling schedulesBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/schedules/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation schedulesByTeamAndSeasonId
     *
     * By Team and Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve schedule from. (required)
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamAndSeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportSchedulesByTeamAndSeasonIdResponse
     */
    public function schedulesByTeamAndSeasonId(
        $season_id,
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['schedulesByTeamAndSeasonId'][0]

    )
    {

        list($response) = $this->schedulesByTeamAndSeasonIdWithHttpInfo($season_id, $team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation schedulesByTeamAndSeasonIdWithHttpInfo
     *
     * By Team and Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve schedule from. (required)
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamAndSeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportSchedulesByTeamAndSeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function schedulesByTeamAndSeasonIdWithHttpInfo($season_id, $team_id, $version = null, $sport = null, string $contentType = self::contentTypes['schedulesByTeamAndSeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->schedulesByTeamAndSeasonIdRequest($season_id, $team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->schedulesByTeamAndSeasonIdWithHttpInfo(
                        $season_id,
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportSchedulesByTeamAndSeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportSchedulesByTeamAndSeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportSchedulesByTeamAndSeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportSchedulesByTeamAndSeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportSchedulesByTeamAndSeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schedulesByTeamAndSeasonIdAsync
     *
     * By Team and Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve schedule from. (required)
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamAndSeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schedulesByTeamAndSeasonIdAsync(
        $season_id,
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['schedulesByTeamAndSeasonId'][0]

    )
    {

        return $this->schedulesByTeamAndSeasonIdAsyncWithHttpInfo($season_id, $team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schedulesByTeamAndSeasonIdAsyncWithHttpInfo
     *
     * By Team and Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve schedule from. (required)
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamAndSeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schedulesByTeamAndSeasonIdAsyncWithHttpInfo($season_id, $team_id, $version = null, $sport = null, string $contentType = self::contentTypes['schedulesByTeamAndSeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportSchedulesByTeamAndSeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->schedulesByTeamAndSeasonIdRequest($season_id, $team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schedulesByTeamAndSeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve schedule from. (required)
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamAndSeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schedulesByTeamAndSeasonIdRequest($season_id, $team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['schedulesByTeamAndSeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling schedulesByTeamAndSeasonId'
            );
        }
        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling schedulesByTeamAndSeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/schedules/seasons/{seasonId}/teams/{teamId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation schedulesByTeamId
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportSchedulesByTeamIdResponse
     */
    public function schedulesByTeamId(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['schedulesByTeamId'][0]

    )
    {

        list($response) = $this->schedulesByTeamIdWithHttpInfo($team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation schedulesByTeamIdWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportSchedulesByTeamIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function schedulesByTeamIdWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['schedulesByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->schedulesByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->schedulesByTeamIdWithHttpInfo(
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportSchedulesByTeamIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportSchedulesByTeamIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportSchedulesByTeamIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportSchedulesByTeamIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportSchedulesByTeamIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schedulesByTeamIdAsync
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schedulesByTeamIdAsync(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['schedulesByTeamId'][0]

    )
    {

        return $this->schedulesByTeamIdAsyncWithHttpInfo($team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schedulesByTeamIdAsyncWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schedulesByTeamIdAsyncWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['schedulesByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportSchedulesByTeamIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->schedulesByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schedulesByTeamId'
     *
     * @param  int $team_id The ID of the team you want to retrieve schedule from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schedulesByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schedulesByTeamIdRequest($team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['schedulesByTeamId'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling schedulesByTeamId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/schedules/teams/{teamId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation seasonById
     *
     * By ID
     *
     * @param  int $season_id The ID of the season you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportSeasonByIdResponse
     */
    public function seasonById(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['seasonById'][0]

    )
    {

        list($response) = $this->seasonByIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation seasonByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $season_id The ID of the season you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportSeasonByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function seasonByIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['seasonById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->seasonByIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->seasonByIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportSeasonByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportSeasonByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportSeasonByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportSeasonByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportSeasonByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seasonByIdAsync
     *
     * By ID
     *
     * @param  int $season_id The ID of the season you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seasonByIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['seasonById'][0]

    )
    {

        return $this->seasonByIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seasonByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $season_id The ID of the season you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seasonByIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['seasonById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportSeasonByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->seasonByIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seasonById'
     *
     * @param  int $season_id The ID of the season you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seasonByIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['seasonById'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling seasonById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation seasonsAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportSeasonsAllResponse
     */
    public function seasonsAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['seasonsAll'][0]

    )
    {

        list($response) = $this->seasonsAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation seasonsAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportSeasonsAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function seasonsAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['seasonsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->seasonsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->seasonsAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportSeasonsAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportSeasonsAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportSeasonsAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportSeasonsAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportSeasonsAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seasonsAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seasonsAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['seasonsAll'][0]

    )
    {

        return $this->seasonsAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seasonsAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seasonsAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['seasonsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportSeasonsAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->seasonsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seasonsAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seasonsAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['seasonsAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/seasons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation seasonsByTeamId
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve seasons from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function seasonsByTeamId(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['seasonsByTeamId'][0]

    )
    {

        list($response) = $this->seasonsByTeamIdWithHttpInfo($team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation seasonsByTeamIdWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve seasons from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function seasonsByTeamIdWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['seasonsByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->seasonsByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->seasonsByTeamIdWithHttpInfo(
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seasonsByTeamIdAsync
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve seasons from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seasonsByTeamIdAsync(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['seasonsByTeamId'][0]

    )
    {

        return $this->seasonsByTeamIdAsyncWithHttpInfo($team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seasonsByTeamIdAsyncWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve seasons from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seasonsByTeamIdAsyncWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['seasonsByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->seasonsByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seasonsByTeamId'
     *
     * @param  int $team_id The ID of the team you want to retrieve seasons from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seasonsByTeamIdRequest($team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['seasonsByTeamId'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling seasonsByTeamId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/seasons/teams/{teamId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation seasonsSearch
     *
     * Search
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportSeasonsSearchResponse
     */
    public function seasonsSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['seasonsSearch'][0]

    )
    {

        list($response) = $this->seasonsSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation seasonsSearchWithHttpInfo
     *
     * Search
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportSeasonsSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function seasonsSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['seasonsSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->seasonsSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->seasonsSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportSeasonsSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportSeasonsSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportSeasonsSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportSeasonsSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportSeasonsSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seasonsSearchAsync
     *
     * Search
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seasonsSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['seasonsSearch'][0]

    )
    {

        return $this->seasonsSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seasonsSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seasonsSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['seasonsSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportSeasonsSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->seasonsSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seasonsSearch'
     *
     * @param  int $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seasonsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seasonsSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['seasonsSearch'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling seasonsSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/seasons/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation squadsBySeasonAndTeamId
     *
     * By Season and Team ID
     *
     * @param  int $season_id The ID of the season you want to retrieve squads from. (required)
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsBySeasonAndTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportSquadsBySeasonAndTeamIdResponse
     */
    public function squadsBySeasonAndTeamId(
        $season_id,
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['squadsBySeasonAndTeamId'][0]

    )
    {

        list($response) = $this->squadsBySeasonAndTeamIdWithHttpInfo($season_id, $team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation squadsBySeasonAndTeamIdWithHttpInfo
     *
     * By Season and Team ID
     *
     * @param  int $season_id The ID of the season you want to retrieve squads from. (required)
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsBySeasonAndTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportSquadsBySeasonAndTeamIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function squadsBySeasonAndTeamIdWithHttpInfo($season_id, $team_id, $version = null, $sport = null, string $contentType = self::contentTypes['squadsBySeasonAndTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->squadsBySeasonAndTeamIdRequest($season_id, $team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->squadsBySeasonAndTeamIdWithHttpInfo(
                        $season_id,
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportSquadsBySeasonAndTeamIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportSquadsBySeasonAndTeamIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportSquadsBySeasonAndTeamIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportSquadsBySeasonAndTeamIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportSquadsBySeasonAndTeamIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation squadsBySeasonAndTeamIdAsync
     *
     * By Season and Team ID
     *
     * @param  int $season_id The ID of the season you want to retrieve squads from. (required)
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsBySeasonAndTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function squadsBySeasonAndTeamIdAsync(
        $season_id,
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['squadsBySeasonAndTeamId'][0]

    )
    {

        return $this->squadsBySeasonAndTeamIdAsyncWithHttpInfo($season_id, $team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation squadsBySeasonAndTeamIdAsyncWithHttpInfo
     *
     * By Season and Team ID
     *
     * @param  int $season_id The ID of the season you want to retrieve squads from. (required)
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsBySeasonAndTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function squadsBySeasonAndTeamIdAsyncWithHttpInfo($season_id, $team_id, $version = null, $sport = null, string $contentType = self::contentTypes['squadsBySeasonAndTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportSquadsBySeasonAndTeamIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->squadsBySeasonAndTeamIdRequest($season_id, $team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'squadsBySeasonAndTeamId'
     *
     * @param  int $season_id The ID of the season you want to retrieve squads from. (required)
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsBySeasonAndTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function squadsBySeasonAndTeamIdRequest($season_id, $team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['squadsBySeasonAndTeamId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling squadsBySeasonAndTeamId'
            );
        }
        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling squadsBySeasonAndTeamId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/squads/seasons/{seasonId}/teams/{teamId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation squadsByTeamId
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportSquadsByTeamIdResponse
     */
    public function squadsByTeamId(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['squadsByTeamId'][0]

    )
    {

        list($response) = $this->squadsByTeamIdWithHttpInfo($team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation squadsByTeamIdWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportSquadsByTeamIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function squadsByTeamIdWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['squadsByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->squadsByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->squadsByTeamIdWithHttpInfo(
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportSquadsByTeamIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportSquadsByTeamIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportSquadsByTeamIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportSquadsByTeamIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportSquadsByTeamIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation squadsByTeamIdAsync
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function squadsByTeamIdAsync(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['squadsByTeamId'][0]

    )
    {

        return $this->squadsByTeamIdAsyncWithHttpInfo($team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation squadsByTeamIdAsyncWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function squadsByTeamIdAsyncWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['squadsByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportSquadsByTeamIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->squadsByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'squadsByTeamId'
     *
     * @param  int $team_id The ID of the team you want to retrieve squads from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['squadsByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function squadsByTeamIdRequest($team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['squadsByTeamId'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling squadsByTeamId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/squads/teams/{teamId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation stageById
     *
     * By ID
     *
     * @param  int $stage_id The ID of the stage you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stageById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStageByIdResponse
     */
    public function stageById(
        $stage_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stageById'][0]

    )
    {

        list($response) = $this->stageByIdWithHttpInfo($stage_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation stageByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $stage_id The ID of the stage you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stageById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStageByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function stageByIdWithHttpInfo($stage_id, $version = null, $sport = null, string $contentType = self::contentTypes['stageById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stageByIdRequest($stage_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->stageByIdWithHttpInfo(
                        $stage_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStageByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStageByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStageByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStageByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStageByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stageByIdAsync
     *
     * By ID
     *
     * @param  int $stage_id The ID of the stage you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stageById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stageByIdAsync(
        $stage_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stageById'][0]

    )
    {

        return $this->stageByIdAsyncWithHttpInfo($stage_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stageByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $stage_id The ID of the stage you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stageById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stageByIdAsyncWithHttpInfo($stage_id, $version = null, $sport = null, string $contentType = self::contentTypes['stageById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStageByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stageByIdRequest($stage_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stageById'
     *
     * @param  int $stage_id The ID of the stage you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stageById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stageByIdRequest($stage_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['stageById'][0])
    {

        // verify the required parameter 'stage_id' is set
        if ($stage_id === SENTINEL_VALUE || (is_array($stage_id) && count($stage_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter stage_id when calling stageById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/stages/{stageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($stage_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'stageId' . '}',
                ObjectSerializer::toPathValue($stage_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation stagesAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStagesAllResponse
     */
    public function stagesAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stagesAll'][0]

    )
    {

        list($response) = $this->stagesAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation stagesAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStagesAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function stagesAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['stagesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stagesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->stagesAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStagesAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStagesAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStagesAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStagesAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStagesAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stagesAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stagesAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stagesAll'][0]

    )
    {

        return $this->stagesAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stagesAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stagesAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['stagesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStagesAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stagesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stagesAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stagesAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['stagesAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/stages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation stagesBySeasonId
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve stages from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStagesBySeasonIdResponse
     */
    public function stagesBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stagesBySeasonId'][0]

    )
    {

        list($response) = $this->stagesBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation stagesBySeasonIdWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve stages from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStagesBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function stagesBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['stagesBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stagesBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->stagesBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStagesBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStagesBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStagesBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStagesBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStagesBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stagesBySeasonIdAsync
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve stages from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stagesBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stagesBySeasonId'][0]

    )
    {

        return $this->stagesBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stagesBySeasonIdAsyncWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve stages from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stagesBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['stagesBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStagesBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stagesBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stagesBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve stages from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stagesBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['stagesBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling stagesBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/stages/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation stagesSearch
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStagesSearchResponse
     */
    public function stagesSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stagesSearch'][0]

    )
    {

        list($response) = $this->stagesSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation stagesSearchWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStagesSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function stagesSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['stagesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stagesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->stagesSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStagesSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStagesSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStagesSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStagesSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStagesSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stagesSearchAsync
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stagesSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stagesSearch'][0]

    )
    {

        return $this->stagesSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stagesSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stagesSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['stagesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStagesSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stagesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stagesSearch'
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stagesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stagesSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['stagesSearch'][0])
    {

        // Check if $name is a string
        if ($name !== SENTINEL_VALUE && !is_string($name)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($name, true), gettype($name)));
        }
        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling stagesSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/stages/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation standingCorrectionsBySeasonId
     *
     * Correction by Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve standing corrections from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingCorrectionsBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStandingCorrectionsBySeasonIdResponse
     */
    public function standingCorrectionsBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingCorrectionsBySeasonId'][0]

    )
    {

        list($response) = $this->standingCorrectionsBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation standingCorrectionsBySeasonIdWithHttpInfo
     *
     * Correction by Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve standing corrections from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingCorrectionsBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStandingCorrectionsBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function standingCorrectionsBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['standingCorrectionsBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingCorrectionsBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->standingCorrectionsBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStandingCorrectionsBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStandingCorrectionsBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStandingCorrectionsBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStandingCorrectionsBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStandingCorrectionsBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation standingCorrectionsBySeasonIdAsync
     *
     * Correction by Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve standing corrections from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingCorrectionsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingCorrectionsBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingCorrectionsBySeasonId'][0]

    )
    {

        return $this->standingCorrectionsBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation standingCorrectionsBySeasonIdAsyncWithHttpInfo
     *
     * Correction by Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve standing corrections from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingCorrectionsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingCorrectionsBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['standingCorrectionsBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStandingCorrectionsBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingCorrectionsBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'standingCorrectionsBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve standing corrections from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingCorrectionsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function standingCorrectionsBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['standingCorrectionsBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling standingCorrectionsBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/standings/corrections/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation standingsAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStandingsAllResponse
     */
    public function standingsAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingsAll'][0]

    )
    {

        list($response) = $this->standingsAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation standingsAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStandingsAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function standingsAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['standingsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->standingsAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStandingsAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStandingsAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStandingsAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStandingsAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStandingsAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation standingsAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingsAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingsAll'][0]

    )
    {

        return $this->standingsAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation standingsAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingsAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['standingsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStandingsAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'standingsAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function standingsAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['standingsAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/standings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation standingsByRoundId
     *
     * By Round ID
     *
     * @param  int $round_id The ID of the round you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsByRoundId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStandingsByRoundIdResponse
     */
    public function standingsByRoundId(
        $round_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingsByRoundId'][0]

    )
    {

        list($response) = $this->standingsByRoundIdWithHttpInfo($round_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation standingsByRoundIdWithHttpInfo
     *
     * By Round ID
     *
     * @param  int $round_id The ID of the round you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsByRoundId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStandingsByRoundIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function standingsByRoundIdWithHttpInfo($round_id, $version = null, $sport = null, string $contentType = self::contentTypes['standingsByRoundId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingsByRoundIdRequest($round_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->standingsByRoundIdWithHttpInfo(
                        $round_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStandingsByRoundIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStandingsByRoundIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStandingsByRoundIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStandingsByRoundIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStandingsByRoundIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation standingsByRoundIdAsync
     *
     * By Round ID
     *
     * @param  int $round_id The ID of the round you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsByRoundId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingsByRoundIdAsync(
        $round_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingsByRoundId'][0]

    )
    {

        return $this->standingsByRoundIdAsyncWithHttpInfo($round_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation standingsByRoundIdAsyncWithHttpInfo
     *
     * By Round ID
     *
     * @param  int $round_id The ID of the round you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsByRoundId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingsByRoundIdAsyncWithHttpInfo($round_id, $version = null, $sport = null, string $contentType = self::contentTypes['standingsByRoundId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStandingsByRoundIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingsByRoundIdRequest($round_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'standingsByRoundId'
     *
     * @param  int $round_id The ID of the round you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsByRoundId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function standingsByRoundIdRequest($round_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['standingsByRoundId'][0])
    {

        // verify the required parameter 'round_id' is set
        if ($round_id === SENTINEL_VALUE || (is_array($round_id) && count($round_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter round_id when calling standingsByRoundId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/standings/rounds/{roundId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($round_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'roundId' . '}',
                ObjectSerializer::toPathValue($round_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation standingsBySeasonId
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStandingsBySeasonIdResponse
     */
    public function standingsBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingsBySeasonId'][0]

    )
    {

        list($response) = $this->standingsBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation standingsBySeasonIdWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStandingsBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function standingsBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['standingsBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingsBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->standingsBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStandingsBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStandingsBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStandingsBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStandingsBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStandingsBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation standingsBySeasonIdAsync
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingsBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingsBySeasonId'][0]

    )
    {

        return $this->standingsBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation standingsBySeasonIdAsyncWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingsBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['standingsBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStandingsBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingsBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'standingsBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve standing from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function standingsBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['standingsBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling standingsBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/standings/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation standingsLiveByLeagueId
     *
     * By League ID
     *
     * @param  int $league_id The ID of the league you want to retrieve standings from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsLiveByLeagueId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStandingsLiveByLeagueIdResponse
     */
    public function standingsLiveByLeagueId(
        $league_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingsLiveByLeagueId'][0]

    )
    {

        list($response) = $this->standingsLiveByLeagueIdWithHttpInfo($league_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation standingsLiveByLeagueIdWithHttpInfo
     *
     * By League ID
     *
     * @param  int $league_id The ID of the league you want to retrieve standings from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsLiveByLeagueId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStandingsLiveByLeagueIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function standingsLiveByLeagueIdWithHttpInfo($league_id, $version = null, $sport = null, string $contentType = self::contentTypes['standingsLiveByLeagueId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingsLiveByLeagueIdRequest($league_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->standingsLiveByLeagueIdWithHttpInfo(
                        $league_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportStandingsLiveByLeagueIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStandingsLiveByLeagueIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStandingsLiveByLeagueIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStandingsLiveByLeagueIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStandingsLiveByLeagueIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation standingsLiveByLeagueIdAsync
     *
     * By League ID
     *
     * @param  int $league_id The ID of the league you want to retrieve standings from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsLiveByLeagueId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingsLiveByLeagueIdAsync(
        $league_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['standingsLiveByLeagueId'][0]

    )
    {

        return $this->standingsLiveByLeagueIdAsyncWithHttpInfo($league_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation standingsLiveByLeagueIdAsyncWithHttpInfo
     *
     * By League ID
     *
     * @param  int $league_id The ID of the league you want to retrieve standings from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsLiveByLeagueId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function standingsLiveByLeagueIdAsyncWithHttpInfo($league_id, $version = null, $sport = null, string $contentType = self::contentTypes['standingsLiveByLeagueId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStandingsLiveByLeagueIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->standingsLiveByLeagueIdRequest($league_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'standingsLiveByLeagueId'
     *
     * @param  int $league_id The ID of the league you want to retrieve standings from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['standingsLiveByLeagueId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function standingsLiveByLeagueIdRequest($league_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['standingsLiveByLeagueId'][0])
    {

        // verify the required parameter 'league_id' is set
        if ($league_id === SENTINEL_VALUE || (is_array($league_id) && count($league_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter league_id when calling standingsLiveByLeagueId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/standings/live/leagues/{leagueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($league_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'leagueId' . '}',
                ObjectSerializer::toPathValue($league_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation stateById
     *
     * By ID
     *
     * @param  int $state_id The ID of the state you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stateById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStateByIdResponse
     */
    public function stateById(
        $state_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stateById'][0]

    )
    {

        list($response) = $this->stateByIdWithHttpInfo($state_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation stateByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $state_id The ID of the state you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stateById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStateByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function stateByIdWithHttpInfo($state_id, $version = null, $sport = null, string $contentType = self::contentTypes['stateById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stateByIdRequest($state_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->stateByIdWithHttpInfo(
                        $state_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStateByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStateByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStateByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStateByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStateByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stateByIdAsync
     *
     * By ID
     *
     * @param  int $state_id The ID of the state you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stateById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stateByIdAsync(
        $state_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['stateById'][0]

    )
    {

        return $this->stateByIdAsyncWithHttpInfo($state_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stateByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $state_id The ID of the state you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stateById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stateByIdAsyncWithHttpInfo($state_id, $version = null, $sport = null, string $contentType = self::contentTypes['stateById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStateByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->stateByIdRequest($state_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stateById'
     *
     * @param  int $state_id The ID of the state you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stateById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stateByIdRequest($state_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['stateById'][0])
    {

        // verify the required parameter 'state_id' is set
        if ($state_id === SENTINEL_VALUE || (is_array($state_id) && count($state_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter state_id when calling stateById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/states/{stateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($state_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'stateId' . '}',
                ObjectSerializer::toPathValue($state_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation statesBySport
     *
     * By Sport
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statesBySport'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportStatesBySportResponse
     */
    public function statesBySport(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['statesBySport'][0]

    )
    {

        list($response) = $this->statesBySportWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation statesBySportWithHttpInfo
     *
     * By Sport
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statesBySport'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportStatesBySportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function statesBySportWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['statesBySport'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->statesBySportRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->statesBySportWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportStatesBySportResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportStatesBySportResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportStatesBySportResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportStatesBySportResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportStatesBySportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation statesBySportAsync
     *
     * By Sport
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statesBySport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function statesBySportAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['statesBySport'][0]

    )
    {

        return $this->statesBySportAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation statesBySportAsyncWithHttpInfo
     *
     * By Sport
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statesBySport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function statesBySportAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['statesBySport'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportStatesBySportResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->statesBySportRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'statesBySport'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['statesBySport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function statesBySportRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['statesBySport'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/states';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation teamsAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTeamsAllResponse
     */
    public function teamsAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsAll'][0]

    )
    {

        list($response) = $this->teamsAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation teamsAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTeamsAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['teamsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->teamsAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTeamsAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTeamsAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTeamsAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTeamsAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTeamsAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsAll'][0]

    )
    {

        return $this->teamsAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['teamsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTeamsAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['teamsAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation teamsByCountryId
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTeamsByCountryIdResponse
     */
    public function teamsByCountryId(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsByCountryId'][0]

    )
    {

        list($response) = $this->teamsByCountryIdWithHttpInfo($country_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation teamsByCountryIdWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsByCountryId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTeamsByCountryIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsByCountryIdWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['teamsByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->teamsByCountryIdWithHttpInfo(
                        $country_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTeamsByCountryIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTeamsByCountryIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTeamsByCountryIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTeamsByCountryIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTeamsByCountryIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsByCountryIdAsync
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsByCountryIdAsync(
        $country_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsByCountryId'][0]

    )
    {

        return $this->teamsByCountryIdAsyncWithHttpInfo($country_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsByCountryIdAsyncWithHttpInfo
     *
     * By Country ID
     *
     * @param  int $country_id The ID of the country you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsByCountryIdAsyncWithHttpInfo($country_id, $version = null, $sport = null, string $contentType = self::contentTypes['teamsByCountryId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTeamsByCountryIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsByCountryIdRequest($country_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsByCountryId'
     *
     * @param  int $country_id The ID of the country you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsByCountryId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsByCountryIdRequest($country_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['teamsByCountryId'][0])
    {

        // verify the required parameter 'country_id' is set
        if ($country_id === SENTINEL_VALUE || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter country_id when calling teamsByCountryId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/teams/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation teamsById
     *
     * By ID
     *
     * @param  int $team_id The ID of the team you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTeamsByIdResponse
     */
    public function teamsById(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsById'][0]

    )
    {

        list($response) = $this->teamsByIdWithHttpInfo($team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation teamsByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $team_id The ID of the team you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTeamsByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsByIdWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['teamsById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsByIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->teamsByIdWithHttpInfo(
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTeamsByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTeamsByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTeamsByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTeamsByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTeamsByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsByIdAsync
     *
     * By ID
     *
     * @param  int $team_id The ID of the team you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsByIdAsync(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsById'][0]

    )
    {

        return $this->teamsByIdAsyncWithHttpInfo($team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $team_id The ID of the team you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsByIdAsyncWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['teamsById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTeamsByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsByIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsById'
     *
     * @param  int $team_id The ID of the team you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsByIdRequest($team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['teamsById'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling teamsById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/teams/{teamId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation teamsBySeasonId
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTeamsBySeasonIdResponse
     */
    public function teamsBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsBySeasonId'][0]

    )
    {

        list($response) = $this->teamsBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation teamsBySeasonIdWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTeamsBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['teamsBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->teamsBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTeamsBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTeamsBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTeamsBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTeamsBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTeamsBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsBySeasonIdAsync
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsBySeasonId'][0]

    )
    {

        return $this->teamsBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsBySeasonIdAsyncWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['teamsBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTeamsBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve teams from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['teamsBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling teamsBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/teams/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation teamsSearch
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTeamsSearchResponse
     */
    public function teamsSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsSearch'][0]

    )
    {

        list($response) = $this->teamsSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation teamsSearchWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTeamsSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['teamsSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->teamsSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTeamsSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTeamsSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTeamsSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTeamsSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTeamsSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsSearchAsync
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['teamsSearch'][0]

    )
    {

        return $this->teamsSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['teamsSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTeamsSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->teamsSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsSearch'
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['teamsSearch'][0])
    {

        // Check if $name is a string
        if ($name !== SENTINEL_VALUE && !is_string($name)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($name, true), gettype($name)));
        }
        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling teamsSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/teams/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation topScorersBySeasonId
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTopScorersBySeasonIdResponse
     */
    public function topScorersBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['topScorersBySeasonId'][0]

    )
    {

        list($response) = $this->topScorersBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation topScorersBySeasonIdWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTopScorersBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function topScorersBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['topScorersBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->topScorersBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->topScorersBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTopScorersBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTopScorersBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTopScorersBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTopScorersBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTopScorersBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation topScorersBySeasonIdAsync
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function topScorersBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['topScorersBySeasonId'][0]

    )
    {

        return $this->topScorersBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation topScorersBySeasonIdAsyncWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function topScorersBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['topScorersBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTopScorersBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->topScorersBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'topScorersBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function topScorersBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['topScorersBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling topScorersBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/topscorers/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation topScorersByStageId
     *
     * By Stage ID
     *
     * @param  int $stage_id The ID of the stage you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersByStageId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTopScorersByStageIdResponse
     */
    public function topScorersByStageId(
        $stage_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['topScorersByStageId'][0]

    )
    {

        list($response) = $this->topScorersByStageIdWithHttpInfo($stage_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation topScorersByStageIdWithHttpInfo
     *
     * By Stage ID
     *
     * @param  int $stage_id The ID of the stage you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersByStageId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTopScorersByStageIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function topScorersByStageIdWithHttpInfo($stage_id, $version = null, $sport = null, string $contentType = self::contentTypes['topScorersByStageId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->topScorersByStageIdRequest($stage_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->topScorersByStageIdWithHttpInfo(
                        $stage_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTopScorersByStageIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTopScorersByStageIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTopScorersByStageIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTopScorersByStageIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTopScorersByStageIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation topScorersByStageIdAsync
     *
     * By Stage ID
     *
     * @param  int $stage_id The ID of the stage you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersByStageId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function topScorersByStageIdAsync(
        $stage_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['topScorersByStageId'][0]

    )
    {

        return $this->topScorersByStageIdAsyncWithHttpInfo($stage_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation topScorersByStageIdAsyncWithHttpInfo
     *
     * By Stage ID
     *
     * @param  int $stage_id The ID of the stage you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersByStageId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function topScorersByStageIdAsyncWithHttpInfo($stage_id, $version = null, $sport = null, string $contentType = self::contentTypes['topScorersByStageId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTopScorersByStageIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->topScorersByStageIdRequest($stage_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'topScorersByStageId'
     *
     * @param  int $stage_id The ID of the stage you want to retrieve topscorers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['topScorersByStageId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function topScorersByStageIdRequest($stage_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['topScorersByStageId'][0])
    {

        // verify the required parameter 'stage_id' is set
        if ($stage_id === SENTINEL_VALUE || (is_array($stage_id) && count($stage_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter stage_id when calling topScorersByStageId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/topscorers/stages/{stageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($stage_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'stageId' . '}',
                ObjectSerializer::toPathValue($stage_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation tranfersByDateRange
     *
     * By Date Range
     *
     * @param  string $start_date The start date you want to retrieve transfers from. (required)
     * @param  string $end_date The end date you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tranfersByDateRange'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTranfersByDateRangeResponse
     */
    public function tranfersByDateRange(
        $start_date,
        $end_date,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['tranfersByDateRange'][0]

    )
    {

        list($response) = $this->tranfersByDateRangeWithHttpInfo($start_date, $end_date, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation tranfersByDateRangeWithHttpInfo
     *
     * By Date Range
     *
     * @param  string $start_date The start date you want to retrieve transfers from. (required)
     * @param  string $end_date The end date you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tranfersByDateRange'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTranfersByDateRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function tranfersByDateRangeWithHttpInfo($start_date, $end_date, $version = null, $sport = null, string $contentType = self::contentTypes['tranfersByDateRange'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->tranfersByDateRangeRequest($start_date, $end_date, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->tranfersByDateRangeWithHttpInfo(
                        $start_date,
                        $end_date,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTranfersByDateRangeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTranfersByDateRangeResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTranfersByDateRangeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTranfersByDateRangeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTranfersByDateRangeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tranfersByDateRangeAsync
     *
     * By Date Range
     *
     * @param  string $start_date The start date you want to retrieve transfers from. (required)
     * @param  string $end_date The end date you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tranfersByDateRange'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tranfersByDateRangeAsync(
        $start_date,
        $end_date,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['tranfersByDateRange'][0]

    )
    {

        return $this->tranfersByDateRangeAsyncWithHttpInfo($start_date, $end_date, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tranfersByDateRangeAsyncWithHttpInfo
     *
     * By Date Range
     *
     * @param  string $start_date The start date you want to retrieve transfers from. (required)
     * @param  string $end_date The end date you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tranfersByDateRange'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tranfersByDateRangeAsyncWithHttpInfo($start_date, $end_date, $version = null, $sport = null, string $contentType = self::contentTypes['tranfersByDateRange'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTranfersByDateRangeResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->tranfersByDateRangeRequest($start_date, $end_date, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tranfersByDateRange'
     *
     * @param  string $start_date The start date you want to retrieve transfers from. (required)
     * @param  string $end_date The end date you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tranfersByDateRange'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tranfersByDateRangeRequest($start_date, $end_date, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['tranfersByDateRange'][0])
    {

        // Check if $start_date is a string
        if ($start_date !== SENTINEL_VALUE && !is_string($start_date)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($start_date, true), gettype($start_date)));
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === SENTINEL_VALUE || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter start_date when calling tranfersByDateRange'
            );
        }
        // Check if $end_date is a string
        if ($end_date !== SENTINEL_VALUE && !is_string($end_date)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($end_date, true), gettype($end_date)));
        }
        // verify the required parameter 'end_date' is set
        if ($end_date === SENTINEL_VALUE || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter end_date when calling tranfersByDateRange'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/transfers/between/{startDate}/{endDate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($start_date !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'startDate' . '}',
                ObjectSerializer::toPathValue($start_date),
                $resourcePath
            );
        }
        // path params
        if ($end_date !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'endDate' . '}',
                ObjectSerializer::toPathValue($end_date),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation transferById
     *
     * By ID
     *
     * @param  int $transfer_id transfer_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTransferByIdResponse
     */
    public function transferById(
        $transfer_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transferById'][0]

    )
    {

        list($response) = $this->transferByIdWithHttpInfo($transfer_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation transferByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $transfer_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTransferByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function transferByIdWithHttpInfo($transfer_id, $version = null, $sport = null, string $contentType = self::contentTypes['transferById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transferByIdRequest($transfer_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->transferByIdWithHttpInfo(
                        $transfer_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Sportmonks\Model\SportTransferByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTransferByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTransferByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTransferByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTransferByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transferByIdAsync
     *
     * By ID
     *
     * @param  int $transfer_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferByIdAsync(
        $transfer_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transferById'][0]

    )
    {

        return $this->transferByIdAsyncWithHttpInfo($transfer_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transferByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $transfer_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferByIdAsyncWithHttpInfo($transfer_id, $version = null, $sport = null, string $contentType = self::contentTypes['transferById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTransferByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transferByIdRequest($transfer_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transferById'
     *
     * @param  int $transfer_id (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transferByIdRequest($transfer_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['transferById'][0])
    {

        // verify the required parameter 'transfer_id' is set
        if ($transfer_id === SENTINEL_VALUE || (is_array($transfer_id) && count($transfer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter transfer_id when calling transferById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/transfers/{transferId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($transfer_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'transferId' . '}',
                ObjectSerializer::toPathValue($transfer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation transfersAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTransfersAllResponse
     */
    public function transfersAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transfersAll'][0]

    )
    {

        list($response) = $this->transfersAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation transfersAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTransfersAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function transfersAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['transfersAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transfersAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->transfersAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTransfersAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTransfersAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTransfersAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTransfersAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTransfersAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transfersAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transfersAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transfersAll'][0]

    )
    {

        return $this->transfersAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transfersAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transfersAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['transfersAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTransfersAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transfersAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transfersAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transfersAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['transfersAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/transfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation transfersByPlayerId
     *
     * By Player ID
     *
     * @param  int $player_id The ID of the player you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByPlayerId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTransfersByPlayerIdResponse
     */
    public function transfersByPlayerId(
        $player_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transfersByPlayerId'][0]

    )
    {

        list($response) = $this->transfersByPlayerIdWithHttpInfo($player_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation transfersByPlayerIdWithHttpInfo
     *
     * By Player ID
     *
     * @param  int $player_id The ID of the player you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByPlayerId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTransfersByPlayerIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function transfersByPlayerIdWithHttpInfo($player_id, $version = null, $sport = null, string $contentType = self::contentTypes['transfersByPlayerId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transfersByPlayerIdRequest($player_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->transfersByPlayerIdWithHttpInfo(
                        $player_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTransfersByPlayerIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTransfersByPlayerIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTransfersByPlayerIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTransfersByPlayerIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTransfersByPlayerIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transfersByPlayerIdAsync
     *
     * By Player ID
     *
     * @param  int $player_id The ID of the player you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByPlayerId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transfersByPlayerIdAsync(
        $player_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transfersByPlayerId'][0]

    )
    {

        return $this->transfersByPlayerIdAsyncWithHttpInfo($player_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transfersByPlayerIdAsyncWithHttpInfo
     *
     * By Player ID
     *
     * @param  int $player_id The ID of the player you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByPlayerId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transfersByPlayerIdAsyncWithHttpInfo($player_id, $version = null, $sport = null, string $contentType = self::contentTypes['transfersByPlayerId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTransfersByPlayerIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transfersByPlayerIdRequest($player_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transfersByPlayerId'
     *
     * @param  int $player_id The ID of the player you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByPlayerId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transfersByPlayerIdRequest($player_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['transfersByPlayerId'][0])
    {

        // verify the required parameter 'player_id' is set
        if ($player_id === SENTINEL_VALUE || (is_array($player_id) && count($player_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter player_id when calling transfersByPlayerId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/transfers/players/{playerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($player_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'playerId' . '}',
                ObjectSerializer::toPathValue($player_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation transfersByTeamId
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTransfersByTeamIdResponse
     */
    public function transfersByTeamId(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transfersByTeamId'][0]

    )
    {

        list($response) = $this->transfersByTeamIdWithHttpInfo($team_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation transfersByTeamIdWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByTeamId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTransfersByTeamIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function transfersByTeamIdWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['transfersByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transfersByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->transfersByTeamIdWithHttpInfo(
                        $team_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTransfersByTeamIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTransfersByTeamIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTransfersByTeamIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTransfersByTeamIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTransfersByTeamIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transfersByTeamIdAsync
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transfersByTeamIdAsync(
        $team_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transfersByTeamId'][0]

    )
    {

        return $this->transfersByTeamIdAsyncWithHttpInfo($team_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transfersByTeamIdAsyncWithHttpInfo
     *
     * By Team ID
     *
     * @param  int $team_id The ID of the team you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transfersByTeamIdAsyncWithHttpInfo($team_id, $version = null, $sport = null, string $contentType = self::contentTypes['transfersByTeamId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTransfersByTeamIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transfersByTeamIdRequest($team_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transfersByTeamId'
     *
     * @param  int $team_id The ID of the team you want to retrieve transfers from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersByTeamId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transfersByTeamIdRequest($team_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['transfersByTeamId'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === SENTINEL_VALUE || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter team_id when calling transfersByTeamId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/transfers/teams/{teamId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($team_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'teamId' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation transfersLatest
     *
     * Last Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTransfersLatestResponse
     */
    public function transfersLatest(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transfersLatest'][0]

    )
    {

        list($response) = $this->transfersLatestWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation transfersLatestWithHttpInfo
     *
     * Last Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersLatest'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTransfersLatestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function transfersLatestWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['transfersLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transfersLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->transfersLatestWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTransfersLatestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTransfersLatestResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTransfersLatestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTransfersLatestResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTransfersLatestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transfersLatestAsync
     *
     * Last Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transfersLatestAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['transfersLatest'][0]

    )
    {

        return $this->transfersLatestAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transfersLatestAsyncWithHttpInfo
     *
     * Last Updated
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transfersLatestAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['transfersLatest'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTransfersLatestResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->transfersLatestRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transfersLatest'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfersLatest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transfersLatestRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['transfersLatest'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/transfers/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation tvStationById
     *
     * By ID
     *
     * @param  int $tv_station_id The ID of the tv station you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTvStationByIdResponse
     */
    public function tvStationById(
        $tv_station_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['tvStationById'][0]

    )
    {

        list($response) = $this->tvStationByIdWithHttpInfo($tv_station_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation tvStationByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $tv_station_id The ID of the tv station you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTvStationByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function tvStationByIdWithHttpInfo($tv_station_id, $version = null, $sport = null, string $contentType = self::contentTypes['tvStationById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->tvStationByIdRequest($tv_station_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->tvStationByIdWithHttpInfo(
                        $tv_station_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTvStationByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTvStationByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTvStationByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTvStationByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTvStationByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tvStationByIdAsync
     *
     * By ID
     *
     * @param  int $tv_station_id The ID of the tv station you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tvStationByIdAsync(
        $tv_station_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['tvStationById'][0]

    )
    {

        return $this->tvStationByIdAsyncWithHttpInfo($tv_station_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tvStationByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $tv_station_id The ID of the tv station you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tvStationByIdAsyncWithHttpInfo($tv_station_id, $version = null, $sport = null, string $contentType = self::contentTypes['tvStationById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTvStationByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->tvStationByIdRequest($tv_station_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tvStationById'
     *
     * @param  int $tv_station_id The ID of the tv station you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tvStationByIdRequest($tv_station_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['tvStationById'][0])
    {

        // verify the required parameter 'tv_station_id' is set
        if ($tv_station_id === SENTINEL_VALUE || (is_array($tv_station_id) && count($tv_station_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter tv_station_id when calling tvStationById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/tv-stations/{tvStationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($tv_station_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'tvStationId' . '}',
                ObjectSerializer::toPathValue($tv_station_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation tvStationsAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTvStationsAllResponse
     */
    public function tvStationsAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['tvStationsAll'][0]

    )
    {

        list($response) = $this->tvStationsAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation tvStationsAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTvStationsAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function tvStationsAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['tvStationsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->tvStationsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->tvStationsAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTvStationsAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTvStationsAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTvStationsAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTvStationsAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTvStationsAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tvStationsAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tvStationsAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['tvStationsAll'][0]

    )
    {

        return $this->tvStationsAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tvStationsAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tvStationsAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['tvStationsAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTvStationsAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->tvStationsAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tvStationsAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tvStationsAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['tvStationsAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/tv-stations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation tvStationsByFixtureId
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve tv-stations from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportTvStationsByFixtureIdResponse
     */
    public function tvStationsByFixtureId(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['tvStationsByFixtureId'][0]

    )
    {

        list($response) = $this->tvStationsByFixtureIdWithHttpInfo($fixture_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation tvStationsByFixtureIdWithHttpInfo
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve tv-stations from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsByFixtureId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportTvStationsByFixtureIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function tvStationsByFixtureIdWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['tvStationsByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->tvStationsByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->tvStationsByFixtureIdWithHttpInfo(
                        $fixture_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportTvStationsByFixtureIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportTvStationsByFixtureIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportTvStationsByFixtureIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportTvStationsByFixtureIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportTvStationsByFixtureIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tvStationsByFixtureIdAsync
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve tv-stations from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tvStationsByFixtureIdAsync(
        $fixture_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['tvStationsByFixtureId'][0]

    )
    {

        return $this->tvStationsByFixtureIdAsyncWithHttpInfo($fixture_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tvStationsByFixtureIdAsyncWithHttpInfo
     *
     * By Fixture ID
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve tv-stations from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tvStationsByFixtureIdAsyncWithHttpInfo($fixture_id, $version = null, $sport = null, string $contentType = self::contentTypes['tvStationsByFixtureId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportTvStationsByFixtureIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->tvStationsByFixtureIdRequest($fixture_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tvStationsByFixtureId'
     *
     * @param  int $fixture_id The ID of the fixture you want to retrieve tv-stations from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tvStationsByFixtureId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tvStationsByFixtureIdRequest($fixture_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['tvStationsByFixtureId'][0])
    {

        // verify the required parameter 'fixture_id' is set
        if ($fixture_id === SENTINEL_VALUE || (is_array($fixture_id) && count($fixture_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fixture_id when calling tvStationsByFixtureId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/tv-stations/fixtures/{fixtureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($fixture_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'fixtureId' . '}',
                ObjectSerializer::toPathValue($fixture_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation venueById
     *
     * By ID
     *
     * @param  int $venue_id The ID of the venue you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venueById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportVenueByIdResponse
     */
    public function venueById(
        $venue_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['venueById'][0]

    )
    {

        list($response) = $this->venueByIdWithHttpInfo($venue_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation venueByIdWithHttpInfo
     *
     * By ID
     *
     * @param  int $venue_id The ID of the venue you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venueById'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportVenueByIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function venueByIdWithHttpInfo($venue_id, $version = null, $sport = null, string $contentType = self::contentTypes['venueById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->venueByIdRequest($venue_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->venueByIdWithHttpInfo(
                        $venue_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportVenueByIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportVenueByIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportVenueByIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportVenueByIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportVenueByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation venueByIdAsync
     *
     * By ID
     *
     * @param  int $venue_id The ID of the venue you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venueById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function venueByIdAsync(
        $venue_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['venueById'][0]

    )
    {

        return $this->venueByIdAsyncWithHttpInfo($venue_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation venueByIdAsyncWithHttpInfo
     *
     * By ID
     *
     * @param  int $venue_id The ID of the venue you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venueById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function venueByIdAsyncWithHttpInfo($venue_id, $version = null, $sport = null, string $contentType = self::contentTypes['venueById'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportVenueByIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->venueByIdRequest($venue_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'venueById'
     *
     * @param  int $venue_id The ID of the venue you want to retrieve. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venueById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function venueByIdRequest($venue_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['venueById'][0])
    {

        // verify the required parameter 'venue_id' is set
        if ($venue_id === SENTINEL_VALUE || (is_array($venue_id) && count($venue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter venue_id when calling venueById'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/venues/{venueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($venue_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'venueId' . '}',
                ObjectSerializer::toPathValue($venue_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation venuesAll
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportVenuesAllResponse
     */
    public function venuesAll(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['venuesAll'][0]

    )
    {

        list($response) = $this->venuesAllWithHttpInfo($version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation venuesAllWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesAll'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportVenuesAllResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function venuesAllWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['venuesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->venuesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->venuesAllWithHttpInfo(
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportVenuesAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportVenuesAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportVenuesAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportVenuesAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportVenuesAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation venuesAllAsync
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function venuesAllAsync(
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['venuesAll'][0]

    )
    {

        return $this->venuesAllAsyncWithHttpInfo($version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation venuesAllAsyncWithHttpInfo
     *
     * All
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function venuesAllAsyncWithHttpInfo($version = null, $sport = null, string $contentType = self::contentTypes['venuesAll'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportVenuesAllResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->venuesAllRequest($version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'venuesAll'
     *
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesAll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function venuesAllRequest($version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['venuesAll'][0])
    {

        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/venues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation venuesBySeasonId
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve venues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportVenuesBySeasonIdResponse
     */
    public function venuesBySeasonId(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['venuesBySeasonId'][0]

    )
    {

        list($response) = $this->venuesBySeasonIdWithHttpInfo($season_id, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation venuesBySeasonIdWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve venues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesBySeasonId'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportVenuesBySeasonIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function venuesBySeasonIdWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['venuesBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->venuesBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->venuesBySeasonIdWithHttpInfo(
                        $season_id,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportVenuesBySeasonIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportVenuesBySeasonIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportVenuesBySeasonIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportVenuesBySeasonIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportVenuesBySeasonIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation venuesBySeasonIdAsync
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve venues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function venuesBySeasonIdAsync(
        $season_id,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['venuesBySeasonId'][0]

    )
    {

        return $this->venuesBySeasonIdAsyncWithHttpInfo($season_id, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation venuesBySeasonIdAsyncWithHttpInfo
     *
     * By Season ID
     *
     * @param  int $season_id The ID of the season you want to retrieve venues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function venuesBySeasonIdAsyncWithHttpInfo($season_id, $version = null, $sport = null, string $contentType = self::contentTypes['venuesBySeasonId'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportVenuesBySeasonIdResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->venuesBySeasonIdRequest($season_id, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'venuesBySeasonId'
     *
     * @param  int $season_id The ID of the season you want to retrieve venues from. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesBySeasonId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function venuesBySeasonIdRequest($season_id, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['venuesBySeasonId'][0])
    {

        // verify the required parameter 'season_id' is set
        if ($season_id === SENTINEL_VALUE || (is_array($season_id) && count($season_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter season_id when calling venuesBySeasonId'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/venues/seasons/{seasonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($season_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'seasonId' . '}',
                ObjectSerializer::toPathValue($season_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation venuesSearch
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sportmonks\Model\SportVenuesSearchResponse
     */
    public function venuesSearch(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['venuesSearch'][0]

    )
    {

        list($response) = $this->venuesSearchWithHttpInfo($name, $version, $sport, $contentType);
        return $response;
    }

    /**
     * Operation venuesSearchWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesSearch'] to see the possible values for this operation
     *
     * @throws \Sportmonks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sportmonks\Model\SportVenuesSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function venuesSearchWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['venuesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->venuesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->venuesSearchWithHttpInfo(
                        $name,
                        $version,
                        $sport,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                default:
                    if ('\Sportmonks\Model\SportVenuesSearchResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Sportmonks\Model\SportVenuesSearchResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Sportmonks\Model\SportVenuesSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Sportmonks\Model\SportVenuesSearchResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sportmonks\Model\SportVenuesSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation venuesSearchAsync
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function venuesSearchAsync(
        $name,
        $version = SENTINEL_VALUE,
        $sport = SENTINEL_VALUE,


        string $contentType = self::contentTypes['venuesSearch'][0]

    )
    {

        return $this->venuesSearchAsyncWithHttpInfo($name, $version, $sport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation venuesSearchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function venuesSearchAsyncWithHttpInfo($name, $version = null, $sport = null, string $contentType = self::contentTypes['venuesSearch'][0], \Sportmonks\RequestOptions $requestOptions = new \Sportmonks\RequestOptions())
    {
        $returnType = '\Sportmonks\Model\SportVenuesSearchResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->venuesSearchRequest($name, $version, $sport, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'venuesSearch'
     *
     * @param  string $name The name you want to search on. (required)
     * @param  string $version The version of the API. (optional)
     * @param  string $sport The sport you want retrieve entities from. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['venuesSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function venuesSearchRequest($name, $version = SENTINEL_VALUE, $sport = SENTINEL_VALUE, string $contentType = self::contentTypes['venuesSearch'][0])
    {

        // Check if $name is a string
        if ($name !== SENTINEL_VALUE && !is_string($name)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($name, true), gettype($name)));
        }
        // verify the required parameter 'name' is set
        if ($name === SENTINEL_VALUE || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter name when calling venuesSearch'
            );
        }
        // Check if $version is a string
        if ($version !== SENTINEL_VALUE && !is_string($version)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($version, true), gettype($version)));
        }
        // Check if $sport is a string
        if ($sport !== SENTINEL_VALUE && !is_string($sport)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($sport, true), gettype($sport)));
        }


        $resourcePath = '/{version}/{sport}/venues/search/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($version !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($sport !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'sport' . '}',
                ObjectSerializer::toPathValue($sport),
                $resourcePath
            );
        }
        // path params
        if ($name !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
